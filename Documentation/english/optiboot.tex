\chapter{The optiboot boot-loader for AVR Micro-controllers}

\section*{}
The optiboot Boot-loader has been created with C language by Peter Knight and
Bill Westfield. I have used the version 6.2 as base
for the here described revised Assembler version.
I would like to underline, that I did not reinvent the
optiboot boot-loader. I have just done some optimizing.
Many adaptions to several target processors and special
board level systems are present with the version 6.2.
The program use parts of the STK500 communication protocol,
which is released with AVR061~\cite{stk500} from Atmel.


\section{Changes and enhancements to the version 6.2}
Basically I have translated the total program in the assembler language
and have rebuild the process for generating the .hex file
with a bash shell script, so that the program length will
be processed automatically to select the start address of the boot-loader
and set the right fuses for that program length.
The selected solution generates some variables during some
interim steps, which are required to solve the steps
to select the right start address and the right fuses.
The start address of the boot-loader for any target processor
depends on the present flash size, the flash requirement
of the boot-loader code and the tile size, which is supported
by the target processor for bootlace.
The tile size means the smallest boot-loader size, which can be supported
by the selected target processor.


For processors like the ATtiny84, which don't support the boot-loader start function,
the page size of the flash memory is used for this calculation.
For the ATtiny84 this are 64 Bytes. Therefore the start address of
the boot-loader is always located at the begin of a flash page.

For all other supported target processors the boot-loader area can be
selected with the fuse bits BOOTSZ1 and BOOTSZ0 (each with the values 0 and 1).
If you put together the both bits, you get a coded boot-loader size
with values between 0 and 3.
Always the value of 3 select the smallest possible boot-loader area.
A value of 2 select a double size, the value 1 the quadruple size
and the value 0 select a size of eight times the smallest size.
The table~\ref{tab:bootsz} at page~\pageref{tab:bootsz} shows a 
overview for the several target processors.
The picture~\ref{fig:PlatinesAndAVRs} shows most of the test boards and processores,
which are used for the optiboot tests.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{../FIG/Samples_AVR_boot.jpg}
\caption{Some Boards and AVRs for the optiboot tests}
\label{fig:PlatinesAndAVRs}
\end{figure}


\section{Features of the optiboot Assembler version}

To avoid many pitfalls when creating an executable boot loader,
the creation of the boot loader file was largely automated.
In addition, settings are also checked and the generation is
canceled with a corresponding error message,
if, for example, the selected operating frequency (AVR\_FREQ) does not match the
fuse setting (CKSEL, CKDIV8) for the clock.
Receiving program data for optiboot is currently only possible via a serial interface. \\

Below are some of the features listed for the optiboot bootloader:
\begin{itemize}

\item {Supports a large number of AVRs, allmost all have been tested for functionality.}

\item {Support the data load for the EEprom memory.}

\item {Fits in 512 Byte Flash in most cases.}

\item {The required fuse setting is changed automatically according to the actual program size.}

\item {The start address, which depends on the program size and the AVR model,
	is automatically calculated and displayed on the screen.}

\item {All serial interfaces available with the respective AVR processor
         can be chosen freely. The first UART is always the default.}

\item {Can emulate the serial interface via software.
	With that options you can also use ATtiny processores without a UART.
        In addition, the TX and RX pins can be freely selected with SOFT\_UART.}

\item {With the SOFT\_UART feature you can select a serial communication with only on AVR pin (RXD and TXD are same).
	The Hardware UART can not use this feature, because the RXD and TXD pins are fixed to the
		manufactor selected pins.}

\item {The Baud rate can be adjusted automatically by the optiboot program.
	For that feature the Baud time is measured by analysing the first incomming serial data byte.
	Different methods of this baud time measurement can be choosed.
	Normally you must deselect the LED Flash function to fit
	the optiboot program data within 512 byte Flash.}

\item {Can be used with AVRs without the bootloader support.\\
        This VIRTUAL\_BOOT\_PARTITION feature can of course also
	be used for AVRs, which has the bootloader support.
	The optiboot program gets bigger, but can then start at every flash memory page.}

\item {By default, a connected LED flashes three times (LED\_START\_FLASHES=3).
	When serial data arrives, the blinking is stopped immediately.}

\item {Instead of the LED flashing at startup, you can also let the LED light up when waiting
	for serial data (LED\_DATA\_FLASH=1).
       By setting LED\_DATA\_FLASH=4 you call select a permanent lit LED.
		The watchdog reset will turn the LED off in this case.}

\item {The length of the generated optiboot depends only on the selected AVR processor and the selected options.
	The version of the installed avr-gcc has no effect, if you use the assembler source.
	So a later check of the installed bootloader can be easier done,
	even with another PC.}

\item {Supports the frequency adjustment of the build in AVR RC-oscillator.
	For some problematic processors this feature enables the use of a
	bootloader with a fix baud rate in this operation mode.}

\item {Installing the optiboot bootloader at a respective AVR can be done with the program avrdude and
	a connected ISP-programmer.
	To initiate this task only a additional ISP=1 is required at the make call.
	With a ISP=2 at the make call you can operate a verify run of avrdude.
	Additionally a read out of the total flash memory of the AVR is possible
	with ISP=3. A ISP=4 will read the complete EEprom data from your AVR processor.}

\end{itemize}

The next features affects only the build process of the boot bootloader:

\begin{itemize}

\item {You can also choose the adapted C-sources to generate the optiboot bootloader.
	Most of the features are possible with this selection also.
	Of course the generated optiboot program will be bigger!
	Please note, that you have to select the EEprom support with the C-source.}

\item {The amount of the screen output iduring the generating of the optiboot program
	can be adjusted with the system variable VerboseLev. 
	The value for VerboseLev can be between 1 and 4, the normal value is 2.}

\item {The screen output can also be colored with the system variable WITH\_COLORS=1.
	If the variable is set to WITH\_COLORS=2, you get a unformatted text on screen.}

\item {The generationg of the optiboot program is controlled by the bash script build\_hex.sh.
	This script will read the required AVR data from the text file avr\_params.def .
	In the same avr\_params.def the script will find the default setting for the fuses and
		other parameters like operating frequency and baud rate for every supported AVR.}

\item {For every supported AVR processor the build\_hex.sh script can find a matching
	file in the avr\_pins directory, where the pin layout of this processor is fixed.
	Because some processors have the same pin layout, some of the AVRs are grouped together.
	In the matching file the default pin for the LED can be found.
	For processors without UART the default pins for RXD and TXD for the software UART
	solution is specified.}

\item {The generating of the optiboot program runs at a Linux System with installed avr packages.
	You can also use a Windows10 system, when you install the Arduino package und additional
	one or more packages, which install the required commands like bash, bc, echo and other tools.
	Tested is the generation at a Windows10 laptop with installed Arduino and Cygwin64 package.}

\item {The selected parameters for the generating of the optiboot bootloader are logged at the
	end of the .lst file and also in a separate .log file.
	You can see the report with the command cat <filename>.log .}

\end{itemize}


\section{Automatic size adaption in the optiboot Makefile}

The boot-loader start address and the required boot-loader size will
be adapted automatically with the bash script build\_hex.sh, wich
is called by the Makefile.
For the calculation some interim variables are created,
which is only possible together with some Linux tools:

\begin{description}
\item [bash] a powerfull command interpreter for running the script files.
\item [bc] a simple calculator, which can operate with input and output-
values in decimal and hexadecimal values.
\item [cat] put the file content to the standard output.
\item [cut] can select part of lines of a text.
\item [echo] shows the specified text at standard output.
\item [grep] shows only lines of a text file which contain the specified string.
\item [tr] can replace or erase characters.
\end{description}

Until now the functions of the bash script is only tested with a Linux System and
with Windows10 together with installed Cygwin64 and Arduino packages.
The new optiboot system does not create .dat interim Files.

Here are the names of the used script files:
\begin{description}

\item [build\_hex.sh] take the settings from the Makefile and produce a
matching optiboot hex-file in Intel format.
The build\_hex.sh scripts call some helping scripts as get\_avr\_params.sh,
avr\_family.sh, show\_led\_pin.sh, show\_rx\_pin.sh and show\_tx\_pin.sh .
If the variable ISP is set, also the script program\_target is called.

\item [program\_target.sh] is called from build\_hex.sh, to check and correct
the hfuse and efuse settings. 
If the configuration result to another number of used bootpages, the BOOTSZ bits
of the ATmega must be changed. The bits are depending on the AVR model
in the hfuse or efuse byte, which does not make the correction easier.
After the required corrections the avrdude program is called with
the script only\_avrdude.sh .

\item [only\_avrdude.sh] makes only one avrdude call with the params
given by the variable DUDE\_PARAMS .
For check of the parameters the call is reported at the terminal.
If the avrdude call returns with an error, the script give some common hints
for error search. At a Linux system a additional search of probably matching serial
interfaces is done.

\item [find\_serials.sh] will search possible interface named for USB-serial converters
at a Linux system.
For this task are matching integrated chips available, which are named by the
Linux driver beginning with /dev/ttyUSB .
There are also some software emulations available at special mikrocontrollers,
which has a integrated USB interface. You can access these Interfaces with
names beginning with /tty/ACM .
For each found Interface the script will check, if a access is possible for you.
For that you must be a member in the group, which is allowed to access the
interface (in most cases dialout).
This script will only called from only\_avrdude, if avrdude returns with error.
You can call this script also by command bash ./find\_serials.sh
For a Windows system this scipt is useless, use the device manager of Windows instead
to find serial interfaces with name COMx .

\item [get\_avr\_params.sh] find for the MCU\_TARGET specified AVR processor
 all required parameters like flash size, the size of a flash page and the
size of a bootloader page. Additionally some default values like operating frequency,
baud rate and fuse settings are set, if not specified by user.
The source file for these settings is avr\_params.def.

\item [avr\_family.sh] build a group name for some AVR processors with identical pin layout.
Usually the group name is identical to the member with the biggest flash
(atmega328 for atmega16 or atmega88).

\item [show\_led\_pin.sh] find the LED pin, which is the default for this processor or group
in the file avr\_pins/<group>.pins
A message is shown to explain this selection. If the user has selected another pin for the
LED, this pin is reported.

\item [show\_rx\_pin.sh] report the selected RX pin for incomming serial data.
If the user did not specify a special selection for SOFT\_UART, the pin is taken from
the avr\_pins/<group>.pins file.

\item [show\_tx\_pin.sh] report the selected TX pin for outgoing serial data.
If the user did not specify a special selection for SOFT\_UART, the pin is taken from
the avr\_pins/<group>.pins file.

\item [baudcheck.tmp.sh] is created during the run of the build\_hex.sh script
with a C-Preprocessor call from the baudcheck.S file.
It is executed in the same run to give you information about the selected
baud rate state.

\end{description}

\section{target selection for the optiboot Makefile}

There can exist different configurations for the same processor type.
The table~\ref{tab:processors} shows some basic configuration
for several target processors.
You can select some parameters also with the make call or by setting
a environment variable of the shell.
These settings will allways replace the default selections.
There are two main variable names, which are given to the bash shell script
build\_hex.sh , TARGET and MCU\_TARGET. The MCU\_TARGET must specify a valid
AVR processor name. The TARGET variable specifies a free selectable name,
but is usually same as the MCU\_TARGET of specify a board name.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
             Name  & MCU & AVR\_ & total & Flash & BP\_ & LFUSE & HFUSE & EFUSE  \\
                   &     & FREQ  & Flash & page  & LEN  &       &       &        \\
                   &     &       &  size & size  &      &       &       &        \\
    \hline
    \hline
         attiny84 & t84   & 16M? &  8K   &  64   & (64) &  62   &  DF   & FE \\
    \hline
         atmega8  & m8    & 16M  &  8K   &  64   & 256  &  BF   &  CC   &  - \\
    \hline
         atmega88 & m88   & 16M  &  8K   &  64   & 256  &  FF   &  DD   &  04 \\
    \hline
       atmega16   & m16   & 16M  &  16K  & 128   & 256  &  FF   &  9C   &  - \\
    \hline
       atmega168  &  m168  & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
       atmega168p &  m168p & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
    \hline
       atmega32   &  m32   & 16M  &  16K & 128   & 256  &  BF   &  CE   &  - \\
    \hline
       atmega328  &  m328  & 16M  &  32K & 128   & 512  &  FF   &  DE   &  05 \\
       atmega328p & m328p & 16M  &  32K  & 128   & 512  &  FF   &  DE   &  05 \\
    \hline
       atmega644p & m644p & 16M  &  64K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1284p & m1284p & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1280  & m1280  & 16M  &  128K & 256   & 1K   &  FF   &  DE   &  05 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{some Processor targets for optiboot Makefile}
  \label{tab:processors}
\end{table}

All size values are shown in byte units, the values for fuses are shown with hexadecimal values.
The frequency values must be specified in Hz units, 16M is the same as 16000000 Hz.
The standard baud rate of the serial interface is 115200 in most cases for the \(16 MHz\) operation.

Additional to the universal processor configurations you can also select
configurations for special boards or operational environment.
The table~\ref{tab:boards} shows the different adjustments.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
    \hline
             Name  & MCU & AVR\_ & BP\_ & L     & H     & E     & BAUD\_ & LED & SOFT\_ \\
                   &     & FREQ  & LEN  &  FUSE & FUSE  &  FUSE & RATE &     & UART \\
    \hline
    \hline
       luminet     & t84 &  1M   & 64v &  F7   &  DD   &  04   & 9600 & 0x  &  -   \\

    \hline
         virboot8  & m8    & 16M & 64v &       &       &       &      &     &      \\
    \hline
       diecimila  &  m168 & (16M) &     &  F7   &  DD   &  04   &      & 3x  &  -   \\
       lilypad    &  m168  & 8M  &      &  E2   &  DD   &  04   &  -   & 3x  &  -   \\
       pro8       &  m168  & 16M &      &  F7   &  C6   &  04   &  -   & 3x  &  -   \\
       pro16      &  m168  & 16M &      &  F7   &  DD   &  04   &  -   & 3x  &  -   \\
       pro20      &  m168  & 16M &      &  F7   &  DC   &  04   &  -   & 3x  &  -   \\
    atmega168p\_lp&  m168  & 16M &      &  FF   &  DD   &  04   &  -   &     &  -   \\
   xplained168pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
       virboot328  & m328p & 16M & 128v &       &       &       &      &     &  -   \\
    atmega328\_pro8& m328p & 8M  &      &  FF   &  DE   &  05   &  -   & 3x  &  -   \\
   xplained328pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
   xplained328p   &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
        wildfire  & m1284p & 16M &      &       &       &      &   -   & 3xB5 &      \\
    \hline
       mega1280    & m1280 & 16M &      &  FF   &  DE   &  05   &  -   &     &  -   \\
    \hline
    \end{tabular}
  \end{center}
  \caption{configured targets for the optiboot Makefile}
  \label{tab:boards}
\end{table}

\section{The Options for the optiboot Makefile}

With the options you can select the feature of the optiboot boot-loader.
For example you can select with the option SOFT\_UART, that a software solution
is used for the serial communication.
Without this option a integrated hardware UART is used for serial communication.
The pin TX (Transmit) is used for serial output and the pin RX (Receive) is used
for serial input. If more than one UART is present at the target processor,
the first interface with the number 0 is used.
But you can also select every other present UART by specify the number with
the option UART (UART=1 for the second present UART).
For the hardware UART interfaces the pins for transmit and receive are fixed
to the specific pins. For the serial communication with software you can
select any pins, which are able to do digital input and output.
More details for the available options you can find in the tables~\ref{tab:options1},
\ref{tab:options2} and \ref{tab:options3}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example         & Function                                            \\
   the Option         &                &                                                     \\
    \hline
    \hline
    F\_CPU         & F\_CPU=8000000 & Tell the program the clock frequency of the processor. \\
                   &                & The value is specified in Hz units (cycles per second). \\
                   &                & The example specifies a frequency of 8 MHz. \\
    \hline
    BAUD\_RATE     & BAUD\_         & Specifies the baud-rate for the serial communication. \\
                   &  RATE=9600     & Always 8 data bits without parity is used. \\
                   &                & Values below 100 will select a measurement and adaptation \\
                   &                & of the baudrate with different technique. \\
    \hline
    SOFT\_UART     & SOFT\_UART=1   & Select a software solution for the serial communication. \\
    \hline
    UART\_RX        & UART\_RX=D0   & Specifies the port and bit number used for the serial input. \\
                   &                & The example select bit 0 of PIND as serial input. \\
                   &                & You can use this option only with the software UART. \\
    \hline
    UART\_TX        & UART\_TX=D1   & Specifies the port and bit number used for the serial output. \\
                   &                & The example select bit 1 of PORTD as serial output. \\
                   &                & You can use this option only with the software UART. \\
    \hline
   INVERSE\_UART  & INVERSE\_UART=1 & Inverse the logic level for RX and TX data.\\
	           &                & This option can only used with software UART. \\
    \hline
    UART           & UART=1         & Select a hardware UART used for the serial communication \\
                   &                & You can only select a UART if more than one is present. \\
		   &		    & This option will also change the default setting for SOFT\_UART.\\
    \hline
 LED\_START\_      & LED\_START\_   & Select a repetition count of flashing cycles for the \\
   FLASHES         &   FLASHES=3    & control LED. A count of 1 or -1 will only flash once \\
                   &                & without a loop. Negative values will switch off a \\
                   &                & additional check of the RX pin of the serial interface. \\
                   &                & The loop is interrupted immediately, if any incoming \\
                   &                & serial data is detected. Please note, that the start of \\
                   &                & application program is delayed with the blink cycles. \\

    \hline
 LED               & LED=B3         & Select a port and bit number for the control LED. \\
                   &                & The example would select the bit number 3 of the \\
                   &                & port B for the LED connection. With the option \\
                   &                & LED\_START\_FLASHES  this LED will flash the \\
                   &                & specified count before the communication start. \\
    \hline
 LED\_DATA\_       & LED\_DATA\_    & The control LED will glow during waiting for \\
      FLASH        &    FLASH=1     & serial input data, if the value is 1. \\
	           &                & If you set the variable to 4, the LED ist switch on \\
		   &                & once at the beginning of the bootloader \\
		   &                & So you can also see, that the bootloader has started, \\
		   &                & but this setting to 4 with a zero LED\_START\_FLASHES \\
		   &                & will save a lot of flash memory. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Important options for the optiboot Makefile}
  \label{tab:options1}
\end{table}

When operating with the internal RC generator, it is quite possible that a serial data transfer
not immediately succeed. This is principle independent of whether the hardware UART interface
or a software solution (SOFT\_UART) is used.
Without additional measurement you can only try with estimated OSCCAL\_CORR values.
Probably the data sheet of the AVR processor can help a little bit.
Here is described at which operating voltage and at what temperature the RC oscillator
was calibrated. 
In addition here is also described the gradient of frequency change with operating voltage,
temperature and OSCCAL modification.

More options are listed in tables~\ref{tab:options2} and~\ref{tab:options3}. 
Some of these options are only interesting for software checks, the frequency adjusting of
the RC-generator and for processors without the boot-loader support.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example        & Function                                            \\
   the Option     &                &                                                     \\
    \hline
    \hline
 TIMEOUT\_MS       & TIMEOUT\_MS=2000 & This option specifies a time limit in ms units \\
                   &                  & for receiving boot data. After this time without \\
                   &                  & data the boot process is aborted and the \\
                   &                  & processor tries to start the user program. \\
                   &                  & Possible values for TIMEOUT\_MS are 500, 1000, 2000, \\
                   &                  & 4000 and 8000. The efffective value can be limited \\
                   &                  & to 2s because of processor limits for the watchdog. \\
                   &                  & If no TIMEOUT\_MS is specified, the time limit is \\
                   &                  & set to 1 second. \\
    \hline
    SUPPORT\_      & SUPPORT\_      & Select the EEprom read and write function for the  \\
    EEPROM         &  EEPROM=1      & boot-loader. If the assembly language is selected as \\
                   &                & source, the EEprom support is enabled without  \\
                   &                & this option, but can be switched off by setting \\
                   &                & the SUPPORT\_EEPROM Option to 0. \\
                   &                & For the C-source the function must be switched \\
                   &                & on (default = off). \\
    \hline
 C\_SOURCE         & C\_SOURCE=1    & Select the C language as source instead of the  \\
                   &                & assembly language (option 0 = assembly).\\
                   &                & The assembly version requires less program space. \\
    \hline
   LFUSE           & LFUSE=EF       & Specifies a desired value for the AVR Low Fuse.\\
	           &                & Only two Hex characters are allowed.\\
    \hline
   HFUSE           & HFUSE=D9       & Specifies a desired value for the AVR High Fuse.\\
	           &                & Only two Hex characters are allowed.\\
    \hline
   EFUSE           & EFUSE=FC       & Specifies a desired value for the AVR Extended Fuse.\\
	           &                & Only two Hex characters are allowed.\\
    \hline
    \end{tabular}
  \end{center}
  \caption{More options for the optiboot Makefile}
  \label{tab:options2}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example        & Function                                            \\
   the Option     &                &                                                     \\
    \hline
    \hline
 BIGBOOT           & BIGBOOT=512    & Select additional space usage for the compiled \\
                   &                & program. This is used only for tests of the \\
                   &                & automatic adaption to the program size. \\
    \hline
VIRTUAL\_          & VIRTUAL\_       & Changes the interrupt vector table of a user program, \\
 BOOT\_            & BOOT\_          & that the boot-loader is called with a Reset. \\
 PARTITION         & PARTITION       & For the start of the user program another \\
		   &                 & interrupt vector is used.          \\
    \hline
 save\_vect\_      & save\_vect\_    & Choose a interrupt vector number for the  \\
      num          &    num=4        & VIRTUAL\_BOOT\_PARTITION method.        \\
    \hline
 OSCCAL\_          & OSCCAL\_       & With the option OSCCAL\_CORR you can adjust the \\
 CORR              & CORR=5         & internal 8~MHz RC-generator of the AVR. \\
                   &                & Is effectless with crystal-operation or external clock! \\
                   &                & The correction value will be subtracted from the actual \\
                   &                & OSCCAL byte. The frequency will be lower with a positive \\
                   &                & correction value. Because the produced Baud rate is \\
                   &                & directly derived from the processor clock, a correct \\
                   &                & selected processor clock is important for a successful \\
                   &                & serial communication. The value must be between -15 and +15. \\
    \hline
 NO\_EARLY\_       &  NO\_EARLY\_   & Prevents the erasing of the flash page before the data \\
 PAGE\_ERASE       & PAGE\_ERASE=1  & is received via the serial interface. \\
                   &                & Programming the flash with this option is about 30\% slower, \\
                   &                & because the deletion otherwise runs parallel to the \\
		   &                & data reception. But the time loss is not so significant, \\
                   &                & because the also carried out data verification takes about \\
		   &                & the same time and is uneffected. This saves about 14 bytes \\
		   &                & of space on the bootloader side of the optiboot, which \\
		   &                & in practice can also mean that the space requirement  \\
		   &                & can be halved due to the AVR technology. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{More options for the optiboot Makefile}
  \label{tab:options3}
\end{table}

\section{Usage of optiboot without a boot-loader area}

For processors without a special boot-loader area in the flash memory, for example the ATtiny84,
a solution is selectable to use the optiboot anyway.
This function can be selected with the VIRTUAL\_BOOT\_PARTITION option.
To start the boot-loader first with every Reset of the processor, the interrupt
vector table of the application program is changed.
At the reset vector location a jump to the optiboot program is registered.
The original start address of the application program will be moved to
another interrupt vector the ''replacement reset vector''.
This interrupt vector should not be used by the application program.
If the boot-loader does not receive any data from the serial interface within
a appropriate time, the boot-loader jump to the location of the replacement
reset vector and start the application program.
The figure~\ref{fig:VectorMove} should illustrate these changes.

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/VectorMove.eps}
\caption{Changes of program data by optiboot}
\label{fig:VectorMove}
\end{figure}

At the left side the content of the program data file (.hex) is shown.
Just to the right the content of the flash memory is shown, as it is modified by the
optiboot boot-loader. At two interrupt vector addresses the content is changed.
At the reset vector address 0 the jump is modified to select the optiboot start address 
as jump target.
At the ''replacement vector address'' 4 the original jump target address of the application
program's reset vector is used as new jump target address of this vector.
One of the problems with this modification is, that usually the program data
is verified by the host after write is finished.
To provide any error message by verify the program data, the optiboot return the
program data without its own modification, not the real content of the interrupt vector table.
The jump target address of the reset vector can be reconstructed with the content
of the replacement vector address.
But the original content of the replacement vector would be lost because there is no
place to save the original content in the flash memory.
Therefore optiboot use the last two places of the EEprom memory to save this original
content of the replacement vector. 
So the verify of the program data is possible without errors, as long as the application
program do not use one of the last two EEprom locations.
Even if the application program use one of the last two EEprom locations,
the boot-loader will be unaffected. Only the program verify by the host is
no longer possible without a error message.
An error message will occur at the location of the replacement interrupt vector.

For processors with more than 8 kByte flash memory two instruction words are used for every
interrupt vector. Normally every of this double words hold one JMP instruction with the
proper jump target address. The optiboot program can respect these JMP vector table too.
But if you use the linker avr-ld with the option --relax, all JMP instructions are replaced
by a RJMP, if this is possible for the target address.
This replacement of JMP instruction in the vector table by RJMP is not respected
by the optiboot program.
The optiboot program assume, that all interrupt vector numbers of a processor with
more than 8 kByte flash hold a JMP instruction.
For that reason a optiboot program with the VIRTUAL\_BOOT\_Partition option will not
work with a application program, which is linked with the --relax option.
The same problem exist, if the application program itself use a RJMP instruction in
one of the two critical interrupt vector positions.

Further you should notice, that you don't activate the BOOTRST fuse together with
with the usage of the VIRTUAL\_BOOT\_PARTITION option.
The reason is, that the start address of the boot-loader can be located to other
addresses with the VIRTUAL\_BOOT\_PARTITION option than without this option.
With the VIRTUAL\_BOOT\_PARTITION the start address can be placed to every
begin of a flash page. For the normal boot-loader support of the AVR the
start address can only respect the single, double, quadruple or octuple size of
a minimum boot-loader size as shown in figure~\ref{fig:pages} at page~\pageref{fig:pages}.


\section{Capabilities of the serial interface with the applied software}

Das Programm für die Erzeugung und Verarbeitung der elektrischen Signale ist in AVR-Assembler geschrieben.
The way of operation is taked over from the Application Note AVR305 of the ATmel Corporation.
However here are some special features build in.
For example it is respected, that we can not use the special bit-instructions SBI, CBI and SBIC for
any port address. You can use this instructions only up to the address 31 (0x1f).
For some higher port addresses up to 63 (0x3f) you can use special input (IN) and output (OUT)
instructions. If the addresses of the port are higher than this value, you must use
the instructions LDS and STS to access this ports. This instructions need 2 processor clocks for
execution and use the double flash memory (2 words or 4 byte) of the other instructions.
The changed cycle number of one loop pass without any additional delay will be automatically
determined by the program. 
This number of cycles is then taken into account for the calculation of the delay loop,
to achieve a correct time for the transmission of a bit.
The diagrams~\ref{fig:getch_timing} and~\ref{fig:putch_timing} should be used to
explain the work of the C-proprocessor.

\begin{figure}[H]
\centering
\scalebox{0.9}{\includegraphics[]{../FIG/uart_getch_timing.eps}}
\caption{Possible variants of the getch function}
\label{fig:getch_timing}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[]{../FIG/uart_putch_timing.eps}
\caption{Possible variants of the putch function}
\label{fig:putch_timing}
\end{figure}

Both loops are generated so that one cycle with the same conditions of INVERSE\_UART option and
address range of the used ports use the same tic count.
So both functions can use the same function for generating the necessary delay.

\subsection{Computing of the delay time}
For the read-in function getch() is the half baud time needed.
From the detection of the start bit a total time of 1.5 times of the baud-time is delayed
to read the first data bit.
Therefore the base loop is designed for the half duration of a bit transmission.
This base loop is called twice in a special way, so that exactly twice the time is get.
Should one clock have been lost by the building of half the time and subsequent doubling,
this clock is compensated by adding a additional NOP command, so that the total time
is exactly correct for the transmission of one bit.
Because of the limited time resolution of the counter loop of 3 tics, a remainder of up to 2 clock tics
is compensated by adding a additional instruction with the right tic count (RJMP or NOP).
Of course, all this happens automatically, because only the loop time of the input function (getch)
and the output function (putch), the clock frequency of the processor and the desired baud rate
must be known. All other parameters like the number of clocks for a subroutine call (RCALL, RET)
are known for the traget processor.
A disadvantage of the base delay loop is the limited number of clocks for the delay.
With the used 8-bit counter only a maximum of 256*3 clocks is possible for the loop delay.
In addition there is the subroutine call of 7 tics, resulting in a half delay time of 775 tics.
This value must be doubled (delay for a whole bit time) and the loop-time of the input or output
function must be added to get the total time possible. Thus the highest achievable delay time is 1559 clocks.
With a \(16 MHz\) clock frequency you can not get a baud rate of 9600 Baud \(104.17\mu s\), because
the limit is only \(97.4\mu s\).
If a 16-bit counter is used by the delay loop, you would get an even worse resolution of time
because one loop cycle would take more time.
In addition, the 16-bit loop probably need to use the carry bit. The 8-bit counter don't use the carry bit.
This problem is solved by gradually doubling the delay times by doubling the delay loop call.
The C-prepocessor checks, if the initial value of the loop counter would match the 8-bit limit (255) at the
selected clock frequency and the desired baud rate.
In this cace the calculation is repeated for a double call of the base delay loop.
If the resulting initial value for the counting loop is still too high, the double call is doubled again.
Currently this procedure is repeated up to a factor 64 of the base time with the 8-bit counter.
At a clock frequency of \(16 MHz\) or \(20 MHz\) it is now possible to set the serial interface to 300 baud.
For every doubling of the delay time, a additional instruction (2 bytes) is required.
With the maximum count of doubling 6 additional instructions (12 byte) are required in the flash memory.
There is no attempt to add additional instructions to compensate the missing tics caused by
the prescaler for saving flash memory.
The baud time error remains clearly below \(1\%\), because the scaler is used only if necessary.
So the base loop has at least 127 passes with approximately 381 tics, The double delay time
makes no error because of the ''NOP'' compensation. Thus the error stays below 1:762 \(0.13\%\). 
The higher baud rates tend to get higher error for the transmission time, because
the time frame of the CPU clock does not match to the desired baud time.
The hardware UART has then the same problem, if it use the same CPU-clock.
If you wish to generate a baud rate of 230400 with a CPU clock rate of \(16 MHz\),
your UART can operate with \(2 MHz\) in the best case.
So you can use either 8 tics with a baud time of \(4\mu s\) or
9 tics with a baud time of \(4.5\mu s\).
For the first case your baud time is \(7.84\%\) too short, for the
second case the baud time is \(3.68\%\) too long.

\subsection{Using more than one serial interface}

The assembler file soft\_uart.S is designed to be included by a different file which hold
a normal assembler source for the AVR family.
For the optiboot application this is done by the optiboot.S file.
The included file soft\_uart.S use many instructions of the
GNU C-preprocessor and includes another file uart\_delay.S for producing a delay loop
for the desired baud rate. Because this include can be repeated with other parameters,
you can produce up to 4 different delay loops for 4 different baud rates.
This feature use the file soft\_uart.S for generatung a getch and a putch function.
For both functions the file uart\_delay.S is included. But for the second call is
usually no new code generated because the calling parameters are the same.
Only if the parameters differ, a new delay loop would be generated.
Please note, that the callings for the delay loop are named with C-preprocessor macros.
This macros are set to a matching delay loop named DOUBLE\_DELAY\_CALL and SINGLE\_DELAY\_CALL,
if you include the uart\_delay.S file before the code of the serial input or output function.

Three constants must be set before any include of uart\_delay.S, named F\_CPU, BAUD\_RATE and 
LOOP\_TICS. The LOOP\_TICS must be set to the count of tics of the serial input or output
loop for one cycle without any additional delay (usually 9 tics).
For every generated delay loop, the total count of delay tics are saved in one of four
different constant names of the C-preprocessor BIT\_CLOCKS\_0, BIT\_CLOCKS\_1,
BIT\_CLOCKS\_2 and BIT\_CLOCKS\_3 . 
Before a new delay loop is generated, the C-preprocessor checks, if any of the already
generated code for a delay match the new requirement.
Because also the file soft\_uart.S must be included to generate the code for the 
serial input and serial output function, you can repeat this include for another
serial interface. But you must set a additional constant for differing the name
in the functions.
If you set the SOFT\_UART\_NUMBER to 1 (\#define SOFT\_UART\_NUMBER 1) before the \#include,
the serial input function is named getch\_1 and the serial output function
is named putch\_1. If you define a constant named NO\_SOFT\_UART\_TX before the
\#include of soft\_uart.S, no serial output function is generated by this include.
The same is done with the serial input function, if you specify the constant NO\_SOFT\_UART\_RX.

\subsection{Serial Input and Output with only one AVR Pin}

Sometimes it makes sense to operate the serial communication only with one pin,
to unlock one of the few IO pins of small AVRs for other use.
With a special circuit technology can be achieved that you can read in data in the
output pauses. The software solution of optiboot can only use the half-duplex operation
in any case.
Thus, at one time, only either data can be send or data can be received.
Normally the output pin with the TX function becomes high in the transmission pauses,
which prevent a data reading on the same pin.
But if the TX output pin is switched to input mode instead of the high level,
a external pull-up resistor can provide the required high level.
In contrast to the fixed high level now a externally connected TX signal
can pull down the level and let the input function read the low level.
A serial resistor in the connection between the common TX/RX pin of the AVR
with the external TX output can serve as pull-up resistor,
because the idle state if the interface is a high signal.
In addition, this serial resistor provides current limiting,
if both TX interfaces send at the same time.
The external RX interface must be connected directly to the common TX/RX pin
to enable the reading of the external RX interface.
The figure~\ref{fig:onewire-simple} should illustrate this simplest connection.

\begin{figure}[H]
\centering
\scalebox{1.0}{\includegraphics[]{../FIG/OneWire_simple.eps}}
\caption{Possible serialconnection to a AVR with one Pin}
\label{fig:onewire-simple}
\end{figure}

Now is the problem, that the mostly full-duplex capable external interface will
read back the own output.
The communication program like avrdude at the external side is usually unprepared for this condition.
One solution for this problem is to adapt the program at the external side to handle
this read back.
But I believe, that this is not a good idea, because this special version will 
have no maintenance or you must repeat this adaption for new versions constantly.
That's why I prefere a hardware solution.
A electronic circuit between the both endpoints must differ, from which side
the data are send.
A corresponding circuit suggestion is shown in figure~\ref{fig:onewire}

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire.eps}}
\caption{Circuit for suppressing the echoes}
\label{fig:onewire}
\end{figure}

The TX data from the PC are transfered directly with the \(1 k\Omega\) resistor
to the combined RX/TX input pin of the AVR.
If the AVR sends data back to the PC, the output can be switch the level close to 0V,
because the \(1k \Omega\) resistor can not avoid this, even though the
PC's TX level remains switched to VCC level.
The date are passed with the both NAND gates of the HEF4093 chip to the PC's RX input a little bit delayed.
The 0V level of the PC's TX signal will prevent this 
The 0V level on the PC-TX prevents exactly this passing on of data and the RX level remains at VCC,
i.e. on the idle signal of the serial transmission.
Problems are given only by the signal change of the PC-TX signal. 
The circuit consisting of a diode, two resistors and a \(18 pF\) capacitor forward the falling edge faster
to NAND input 6 than the rising edge.
only two NAND gates are required for the function. the other two NAND gates are used for a optional
display of TX/RX activity.
With this circuit you can use an unchanged transfer program like avrdude for example.
The circuit is largely independent of the selected baud rate.
I expect only problems with very high baud rates.
At 115200 baud the circuit operates well. Much higher baud rates can 
not be used in most cases with the software serial interface.
A simular circuit with a 74HC14 Hex Schmitt Inverter is shown in figure~\ref{fig:onewire2}. 

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire2.eps}}
\caption{Alternative circuit for suppressing the echoes}
\label{fig:onewire2}
\end{figure}


\subsection{Use of the automatic baud rate detection}
\label{sec:autobaud}

If you specify a baud rate below \(100Baud\) for generating the bootloader code,
the program will be prepared to detect the baud rate from the first
received character.
At the begin if the transmission with the STK500 protocol the computer send
a command STK\_GET\_SYNC (0x30) followed by the control character CRC\_EOP (0x20).
For the serial transmission protocol the High level (1) is defined as the idle state.
The begin of a transmission is started by s start bit with Low level (0).
Directly after the end of the start bit the first data bit is send 
beginning with the low order bit. After the last of the aggreed count of bits (8)
is transmitted, the transmission is finished with one or more Stop bits at High level (1).
The level of every bit is hold exactly the aggreed baud time.
The time between the end of the last Stop bit and the begin of the next Start bit
is unspecified.
The figure~\ref{fig:AutoBaud} shows the expected results for all possible
time measurement. At the time axis ''t'' four possible start positions
are marked for a complete time measurement of the assumed character.
The counter is started in each case of a detected 1-0 slope.
The right start position for the STK\_GET\_SYNC character is marked with ''1''.
The marks ''2'', ''3'' and ''4'' show the situation for three possible
wrong Start bit detections.
For the mark ''2'' and ''4'' a 1-0 slope of data bits is detected as Start bit
in a wrong way. For the mark '3' is a Start bit correctly detected, but for the
wrong character (CRC\_EOP).
The wrong detections are allways possible, if the bootloader is started not
before the transmission was running.
The expected counter values are marked at the counter level graph for all
four start positions in figure~\ref{fig:AutoBaud}. 
The ''b'' means the counter reading for one bit transmission time (baud time),
the ''d'' stand for a possible time delay between the end of the Stop bit transfer 
and the start of a new Start bit.
The ''D'' represents a expected long time delay to the begin of the next message.
The transmit sequence of the message has reached it's end and the computer
wait for an answer of the AVR.
In the ''Rx''-row the data bits are labled with ''0'' (least significant bit)
to ''7'' (highest significant bit). The Start bit has the label 'A' and
a Stop bit has the label 'E'.
The first byte is the coding of the STK\_GET\_SYNC character and the second byte
is the coding of the control character CRC\_EOP.

\begin{figure}[H]
\centering
\scalebox{0.55}{\includegraphics[]{../FIG/AutoBaud.eps}}
\caption{Possibel timer measurements for the STK\_GET\_SYNC sequence}
\label{fig:AutoBaud}
\end{figure}

\begin{itemize}

\item {Simplest way of baud rate measurement, BAUD\_RATE 20-29}

The simplest form of baud rate measurement doesn't take into account
the wrong start bit choise.
It is assumed, that the detected Start bit belongs to the STK\_GET\_SYNC
character.
After the Start bit detection the program waits to the next 0-1 slope
and starts a 16-bit counter with the frequency F\_CPU/8 with the
stating value -1. At the next 1-0 slope the counter value is read out
and the half of this value is taken as frequency divider for the UART.
The building of the half value is required because the time of two data bits (4-5)
was measured.
Normally 1 must be subtracted for the UART frequency divider.
But when halving should be rounded, a 1 must be added before the halving.
Because also 2 can be subtracted from the counter result instead of
1 from the division result, totally only one must be subtracted from the
counter result. In order to save computation steps, the subtraction (2-1=1)
from the count is done by a start value of the counter of -1.

This method works well, if the bootloader is started automatically just
before the transmission by generating a reset pulse from the DTR (Data Terminal Ready)
signal of the serial interface.
You can also be successfull without the automatically generated Reset,
if a Reset key is connected to the AVR, which should be hold pressed
until the transmission program is started.
But this procedure requires some feeling for the right release time
of the button.

The bootloader only waits a maximum time for the beginning of the transmission,
which is specified from the watchdog timer.
When the watchdog timer triggers a reset, usually the user program is started.
Only if no user program has been loaded yet, the boot loader starts again for a retry.

\item {Improved way of baud rate measurement, BAUD\_RATE 30-39}

Same as the simple way of baud rate measurement this method does not
check the correctness of the bit change sequence.
But the software wait for the next 0-1 slope until the counter value
is read.
		So this counter reading is the time of four data bits (4-7),
which is then used for the baud rate determination.
Because the time recording is slightly inexact because of the
polling loop, the baud time result will be better with dividing by four
than by dividing by two.
For that reason this method should be prefered, if little flash memory
use is important. This improved method use only 4 byte more than the
simple way.

\item {Simplest way of baud rate measurement with time limit, BAUD\_RATE 40-49}

The same method as the simplest way is used for this method.
Only a additional limitation for the timer value is used here.
If the time limit is passed over, the program starts again with the search
for a new Start bit.
Without this limitation the program can stay in a loop for detecting
a low level for the start condition ''4''. 
Probably the bad situation with the start position ''4'' in the 
diagram~\ref{fig:AutoBaud} can be handled a little better. 
The restart of the start bit search with the time limit would
delay a reset from the watchdog timer only a little bit.
The bootloader program may not reset the watchdog timer inside
the search loop, because then the user program is never started
without the transmission of a new program.
For this reason the time limit of the watchdog timer must be greater
as the time delay for repeating the STK\_GET\_SYNC sequence
without a answer to the previous STK\_GET\_SYNC sequence.

\item {Improved way of baud rate measurement with time limit, BAUD\_RATE 50-59}

The baud rate measuring is done in the same way as described for the
improved way (30-39).
Simular to the method ''40-49'' the wait time for the 1-0 slope
is limited to the overflow of the 16-bit counter.
But because the counter value is normally read at the next 0-1 slope,
the result is equal to the improved way without the time limit.


\item {Complex check of baud rate measurement, BAUD\_RATE 60-69}

With this method the counter is started immediately with the detection
of a Start bit and the counter value is read with every of the
next 3 bit changes.
The time sequence of bit changes for the STK\_GET\_SYNC character is 
measured with this method, if the start position is well (''1'').
With this measured time sequence some plausibility checks are done.
For a first is checked, that the difference between the third counter
reading and the first counter reading is less than the value
of the first reading.
For the start position ''1'' this is the case ((9b~-~5b) < 5b).
For the wrong start position ''3'' this is unfortunately also the case ((9b~-~6b) < 6b)
But this test will fail for start condition ''2'', if the time delay ''d'' of
the second start bit of the STK\_GET\_SYNC sequence is sufficiently small.
For the wrong start position ''4'' can help only a time limitation for
the second bit change wait loop, because the repetition of the STK\_GET\_SYNC
is done after a longer wait time for the answer (''D''). 

A second test checks, if the difference between the third and the
second counter reading isn't significant greater than the difference
between the second and the first counter reading.
For the correct start posistion ''1'' this result to the equation ((9b-7b) < (7b-5b+4))
or (2b < 2b+4).
For the false start position ''2'' you get the equation ((9b-3b) < (3b+d-2b+4)) or
(6b < (b+d+4)).
For the false start position ''3'' we get the equation ((9b-7b) < (7b-6b+4)) or (2b < (b+4)).
This exams are relatively safe for detecting the right baud rate, but they
require a lot of additional space for the program.
This method is especially recommended, if at least 1024 bytes are reserved
for the boot loader anyway (boot loader page size).
For setting the correct UART frequency divider, the difference between 
the third counter reading and the second counter reading is divided by 2
(9b-7b-1)/2 = (2b+1)/2-1.

\item {Complex check of baudrate measuring, BAUD\_RATE 70-79}

All counter readings and checks are done in the same way as the
BAUD\_RATE 60-69 method. Only the calculation of
the UART divider is based on the time of four bits instead of two bits.
Consequently the equation for the correct starting position
look like (9b-5b-2)/4 = (4b+2//4-1.

\item {Complex check of baudrate measuring, BAUD\_RATE 80-89}

All counter readings and checks are done in the same way as the
BAUD\_RATE 60-69 method. Only the calculation of
the UART divider is based on the time of nine bits instead of two bits.
Consequently the equation for the correct starting position
look like (9b-4)/9 = (9b+5)/9-1.

\item {Simple way of baud rate measurement, BAUD\_RATE 10-19}

With this selection the time of 9 serial bits is measured without checks
to build the baud rate.
Usually the measurement of the time of 4 serial data bits should be sufficient
to determine the baud rate.

\end{itemize}

I recommend for all methods of the baud rate determination to omit
the LED flashing at the begin of the bootloader program
to prevent a delay of the start bit detection.
Unfortunately even the simplest way of baud rate measurement
need so much additional program memory, that the bootloader
will not fit into the 512 byte limit, if the EEprom support
is selected (SUPPORT\_EEPROM=1) with the flashing LED function.
For some processors you can select the additional function LED\_DATA\_FLASH
without exceeding the 512 byte limit, when the EEprom support is deselected.
If the 512 byte limit is overshoot by a required function,
the next limit of 1024 byte give enough space for all additional
selections.
You can select the SOFT\_UART function together with the automatic
baud rate detection (BAUD\_RATE \textless 100) only for the
assembler version of optiboot, not for the C-version.

The following table~\ref{tab:AutoBaudControl} summarize the different options.
The specified program sizes in bytes refer to an ATmega328 without LED flashing function,
but with the EEprom support.
The program sizes in brackets result from the operation of the serial interface with software.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
    BAUD\_RATE  & Bit   & Clock  & Time  & Check & mega328\\
		& Base  & Base   & Limit &       & size (HW) \\
    \hline
    \hline
	    10-14      &  9     & clk/8 &   -    & simple  & 502  \\
    \hline
	    15-19      &  9     &  clk  &   -    & simple  & 502  \\
    \hline
	    20-24      &  2     & clk/8 &   -    & simple  & 490  \\
    \hline
	    25-29      &  2     &  clk  &   -    & simple  & 494  \\
    \hline
	    30-34      &  4     & clk/8 &   -    & simple  & 494  \\
    \hline
	    35-39      &  4     &  clk  &   -    & simple  & 494  \\
    \hline
	    40-44      &  2     & clk/8 &   Yes  & simple  & 496  \\
    \hline
	    45-49      &  2     &  clk  &   Yes  & simple  & 500  \\
    \hline
	    50-54      &  4     & clk/8 &   Yes  & simple  & 500  \\
    \hline
	    55-59      &  4     &  clk  &   Yes  & simple  & 500  \\
    \hline
    \hline
	    60-64      &  2     &  clk/8 &  Yes  & complex & 550  \\
    \hline
	    65-69      &  2     &  clk   &  Yes  & complex & 554  \\
    \hline
	    70-74      &  4     &  clk/8 &  Yes  & complex & 554  \\
    \hline
	    75-79      &  4     &  clk   &  Yes  & complex & 554  \\
    \hline
	    80-84      &  9     &  clk/8 &  Yes  & complex & 564  \\
	    90-94      &        &        &       &         &      \\
    \hline
	    85-89      &  9     &  clk   &  Yes  & complex & 564  \\
	    95-99      &        &        &       &         &     \\

    \hline
    \end{tabular}
  \end{center}
  \caption{Setting options for the baud rate measurement.}
  \label{tab:AutoBaudControl}
\end{table}


There are some differencies and special features for the baud rate measuring
together with the Soft UART solution compared to the hardware UART solution.
Usually a 8-Bit counter loop is used to generate the delay for the half baud time.
Because of the used instructions in this loop, you can select the time
only with a solution of 3 clock tics.
To get the full baud time the loop must be called twice, so that
the resolution is doubled too.
With a known fixed baud rate this error will be compensated by extra instructions.
But this is impossible, if the baud rate  is unknown in advance.
To get the best possible rounding of the selected baud rate,
the time measurement should be done with the 16-bit counter at the full CPU clock rate (F\_CPU).
For the hardware UART the counter can be used with F\_CPU/8, because the UART
use a identical clock rate and the time is measured for 2 or 4 bits.

The use of a 8-bit delay loop result to a upper limit of the baud time
depending on the CPU clock rate.
The resulting minumum baud rate is definite higher with the 8-bit loop
compared to the minimum baud rate with the hardware UART.
With the limited resolution of the period selection for the baud rate
the upper limit can be specified with a guaranteed baud rate error below 2\%.
If the AVR processor is operated with a RC clock generator, the clock rate
is usually imprecise. By measuring the baud rate with a counter controlled
with the same clock, this error is compensated.
But the error by reason of the limited resolution of the baud rate divider 
can not be calculated in advance.
I would like to show you what I mean by an example for the hardware UART. 
The baud rate \(250kHz\) can be used with a clockrate of exactly \(8MHz\).
If you select the divider of 4, the desired baud rate is together with
the factor 8 prescaler produced without a deviation.
If I assume a inexact real clock rate of \(7.6MHz\),
the best selectable divider is still 4.
For this case the actual baud rate is now \(237.5kHz\) with the same
error of -5\% as the base clock rate.
To overcome at least the lower baud limit with the software UART solution,
all baud rate selections between 20 and 99, which are odd-numbered,
will generate a code with a 15-bit delay loop.
Unfortunately the pass time of this loop is 5 tics for the 15-bit loop.
Because of the double delay call for the full baud time,
the resolution is only 10 tics and thereby more worth than the 
8 tics resolution of the hardware UART caused by the 8:1 prescaler.
You should use this option only, if you need the support of low baud speeds
and deside not to use very high baud rates.
The following table~\ref{tab:AutoBaud8} is intended to clarify the use of
the different auto baud functions at the operating frequency \(8MHz\).
The table does not respect the time error, which can be caused by the
polling loops for the RX signal.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
   BAUD\_RATE  & SOFT\_ & Minimum   & BAUD-Err & Comment  \\
   Option      & UART   & Baud      & \textless 4\% @ Baud &  \\
    \hline
    \hline
  10-14,20-34  &  0     &  244      &   80.0k  & HW\_UART 2-Bit Time  \\
  40-54,60-64  &        &           &          & or CLK/8 measurement    \\
  70-74,80-84  &        &           &          &                         \\
    \hline
  35-39,55-59  &  0     &  488      &   80.0k  & HW\_UART 4-Bit Time, CLK  \\
    \hline
  15-19,85-89  &  0     &  1098     &   80.0k  & HW\_UART 9-Bit Time, CLK  \\
  25-29,45-49  &        &           &          & HW\_UART 2-Bit Time, CLK \\
  65-69,75-79  &        &           &          & HW\_UART 2/4-Bit Time, CLK \\
    \hline
    42         &  1     &  5151     &   81.6k  &  Simple, 2-Bit Time, 8-Bit Loop  \\
    \hline
    62         &  1     &  5151     &   81.6k  & Complex, 2-Bit Time, 8-Bit Loop  \\
    \hline
    72         &  1     &  5151     &   81.6k  & Complex, 4-Bit Time, 8-Bit Loop  \\
    \hline
    47         &  1     &  244      &   53.3k  &  Simple, 2-Bit Time, 15-Bit Loop \\
    \hline
    67         &  1     &  1220     &   53.3k  & Complex, 2-Bit Time, 15-Bit Loop \\
    \hline
    77         &  1     &  1220     &   53.3k  & Complex, 4-Bit Time, 15-Bit Loop \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Limits for the automatic baud rate selection with a \(8MHz\) clock.}
  \label{tab:AutoBaud8}
\end{table}

Usually a limit for the baud error is set to only 2\%, because the transmitter and
the receiver can have a baud rate error to the opposite direction.
The Auto-baud function measure the actual baud rate of the transmitter,
so that the error rate of the Auto-baud function can take the double value of 4\%.
If you select a hardware UART interface, you can select the standard
baud rates 1200, 2400, 4800, 9600, 19200 and 38400 with all arbitrary options.
Higher baud rates than the specified 40 kBaud are not safe to use,
although 57600 baud also worked well in tests.
Likewise, a test with 115.2 kBaud at \(16MHz\) crystal operation was still successful
when using a software UART with a 15-bit delay loop.
If only a 8-bit delay loop is used with the software UART solution,
the baud rates 1200, 2400 and 4800 can not be used.
The lower baud rates are only usable with the software UART, if you configures
the optiboot with a 15-bit delay loop.
The different limit for the 49 and 69 or 89 baud rate selection is caused
by the different use of the 16-bit AVR counter.
With the 49 selection (all below 60) only the time of two data bits is measured
with the counter. For selections above 59 the complete byte sequence is
measured from the Start bit to the Stop bit with the 16-bit counter.
Probably baud rated below 9600 are rarely used anyway.
Of course the limits of the baud rates change with other processor clock rate.

There are numerous setting options for the UART interface software, which on the
one hand relate to the measurement base of the baud time, but also relate to the type
of delay calculation.
In the table~\ref{tab:AutoBaudLen328} the program lengthes of the bootloade are shown
for a ATmega328 target processor.
Unfortunately the programs in the colums labled with \_0 and \_5, this means all
Baud rate selections ending with the digit 0 or 5, are practical unusable.
The reason herefore is, that the division operation by successive subtraction
is too slow to finish before the serial data stop bit ends.
A workaround would be to let the transmitter of the data (avrdude) send all data with 2 stop bits.
Because this is not intended by the avrdude version 6.3,
the other columns use an accelerated subtraction loop,
which then causes a longer program.
If possible, the faster shift operation for division by powers of 2 is used instead of the subtraction loop.
To enable this shift operations, the colums labled with \_3, \_4, \_8 and \_9 
has increased the number of cycles for one delay loop pass (8T or 16T, T for tics).
Unfortunately the program length is only shorter compared to the subtraction loop,
if the count of shift operation is below 3, which would spare the loop operation for the shifts.
But you can save 14 bytes of flash with the option NO\_EARLY\_PAGE\_ERASE , so that about
30 versions more match to a 512 byte limit.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c| c | c | c || c | c | c | c | c |}
    \hline
    BAUD\_RATE  &  \_0 & \_1   &  \_2 & \_3   & \_4    &  \_5  &  \_6  &   \_7 &  \_8   &  \_9 \\
    ,Measurement base   & 6T/8T &  10T &  6T  &  16T  &  8T    &  10T  &  6T   &  10T  &   8T   &  16T \\
    \hline
       & \multicolumn{5}{c ||}{ simple CLK/8}    &  \multicolumn{5}{c |}{simple CLK/1}      \\
    \hline
   1\_ , 9Bit   & 512  & 526   & 518  & 530   & 518    &  522  &  518  &  528  &  520   &  532 \\
   2\_ , 2Bit   & 514  & 530  & 520 & 522 & \textbf{508} & 518 & 514 & 524 & \textbf{512} & 522 \\
   3\_ , 4Bit   & 510  & 526  & 516 & 524 & \textbf{512} & 520 &  516  &  528  &  514   & 532 \\
   4\_ , 2Bit   & 520  & 536  & 526 & 528     & 514    & 524 &  520  &  530  &  518   & 528 \\
   5\_ , 4Bit   & 516  & 532   & 522  & 530   & 518    &  526  &  522  &  534  &  520   &  538 \\
    \hline
      & \multicolumn{5}{c ||}{ komplex CLK/8}    &  \multicolumn{5}{c |}{komplex CLK/1}      \\
    \hline
   6\_ , 2Bit   & 574  & 590   & 580  & 582   & 578    &  578  &  574  &  584  &  572   &  582 \\
   7\_ , 4Bit   & 572  & 588   & 578  & 592   & 580    &  580  &  576  &  588  &  580   &  592 \\
   8\_ , 9Bit   & 574  & 588   & 580  & 592   & 580    &  584  &  580  &  590  &  582   &  594 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Bootloader program length with automatic Baud rate selection for Software UART}
  \label{tab:AutoBaudLen328}
\end{table}


Finally I would like to show the results from tests, which I have done with
a ATmega1281 with the internal \(8MHz\) RC-generator clock at a specified baud rate
and also above the specified baud rate.
The frequency was tuned with the OSCCAL\_CORR option in steps of two and
of course measured.
The functionality was tested by loading a small user program.
All tests within the specified baud rate was successfull.
Because all tests run well, additionally tests with a higher baud rate than
specified (\(115.2 kBaud\)) was also done.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c || c | c | c || c |  c | c |}
    \hline
  OSCCAL  & Freq.    & HW-UART & SW-UART & HW-UART & \multicolumn{2}{c |}{SW-UART} \\
   \_CORR  & MHz       & 57600   & 57600  & 115200  & \multicolumn{2}{c |}{115200} \\
           &           & Mode 82 & Mode 82 & Mode 56 & Mode 52 & Mode 57 \\
    \hline
    \hline
    20     &  7.18   &  OK       &   OK    &  Err    &  Err    &   Err \\
    18     &  7.22   &  OK       &   OK    &  Err    &  Err    &   Err \\
    \hline
    16     &  7.35   &  OK       &   OK    &  OK     &  OK     &   Err \\
    14     &  7.45   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
    12     &  7.56   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    10     &  7.63   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
     8     &  7.75   &  OK       &   OK    &  OK     &  OK     &   OK  \\
     6     &  7.84   &  OK       &   OK    &  Err    &  OK     &   Err \\
    \hline
     4     &  7.98   &  OK       &   OK    &  Err    &  Err    &   Err \\
     2     &  8.04   &  OK       &   OK    &  Err    &  OK     &   Err \\
    \hline
     0     &  8.18   &  OK       &   OK    &  OK     &  OK     &   Err \\
    -2     &  8.29   &  OK       &   OK    &  OK     &  OK     &   Err \\
    \hline
    -4     &  8.42   &  OK       &   OK    &  OK     &  OK     &   Err \\
    -6     &  8.51   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
    -8     &  8.64   &  OK       &   OK    &  OK     &  Err    &   OK  \\
    -10    &  8.77   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    -12    &  8.92   &  OK       &   OK    &  Err    &  OK     &   OK  \\

    \hline
    \end{tabular}
  \end{center}
  \caption{Test for the automatic baud rate at \(8MHz\) clock.}
  \label{tab:AutoBaudTest8}
\end{table}

For the operating mode 82 I have additionally checked the odd OSCCAL\_CORR settings without
any noticeable difficulties. The also checked simplest mode 42 has not shown
any difficulties with the tested even OSCCAL\_CORR values of the table.

Only at the extemely high baud rate of \(115,2k\) for this CPU frequency the operation
mode 52 shows four failures and with the operation mode 57 eight failures are stated.
The increase in failures in mode 57 with the 15-bit delay loop is expected and caused by
the coarser grid of adjustable delay times.

A test with a chinese Arduino UNO board, which use a CH340G chip as USB-serial converter,
could operate only up to \(38.4kBaud\) correctly.
With higher baud rates the read back of the flash data caused problems.
Probably the last byte of a package is sometimes not transmitted to the host and
the communication blocks.
The same test with a other Arduino UNO board, which use a Mega16U2 controller
for USB-serial conversion, didn't show the same problem.
This board could run with \(115.2kBaud\) and also with \(230.4kBaud\). 
Probably the reason is, that both processors (ATmega328p and Mega16U2)
use a real baud rate of \(250kBaud\).

\subsection{Special features of the serial interface}

Usually optiboot send the serial data with a prolongate stop bit.
The hardware UART switch on a second stop bit for transmitted data and the
software solution use a additional half stop bit.
This seems to be usefull with little differences of the baud rate between sender and receiver,
because there is more time for the receiver to synchronize with the next start bit.
The PC side with avrdude version 6.3 could send data with two stop bits.
So I had pached the sources for avrdude to add this feature with the additional option -S.
But unfortunately this feature is missing with avrdude.

You can disable the two stop bit selection of optiboot with the option TWO\_STOP\_BITS=0.
The difference in speed is insignificant, so I would recommend to use the longer stop bit.\\

The software for the serial interface (SOFT\_UART=1) use the delay time for the stop bits
at the begin of the serial transmission. With that feature the program has more time
at the end of transmission to prepare the receiving of serial data.
You can also disable this feature with the option QuickStopBit=0. But I know no problems
or disadvantages with this feature, not even when operating with just one pin.



\section{Some examples of building a optiboot bootloader}\label{Examples}

The first example is the building of a bootloader for the popular ATmega328P:

\begin{verbatim}
optiboot $ make atmega328p

Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    488       0       0     488     1e8 optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}


With no additional option a baudrate of 115200 with a clock frequency of \(16 MHz\) is selected.
For serial output the hardware interface is selected.
You should notice, that the systematic baud rate error is above 2\% with the hardware UART.
The second example with the same processor is done with a software solution for the serial interface.

\begin{verbatim}
optiboot $ make atmega328p SOFT_UART=1

Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=01 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200, SoftUART_Real: 115107, Delay: 116*1, Difference=-.07%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    504       0       0     504     1f8 optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}

Please note, that the software solution for the serial interface requires a little more flash memory,
but take use of only 1 boot page too. The systematic baud rate error is much smaller than the error with the hardware UART.
But the hardware UART has the advantage, that the input and output could be done simultaneous and is more tolerant against
short disturbance of the input signal.
For the software serial interface you can specify every digital IO-pin for input (UART\_RX) and output (UART\_TX). 
In this example the feature is used to automatically select the RX and TX of the hardware UART.
The automatic IO-pin selection depends on the selected processor type and the selected UART number, if more than
one UART is available.


The last examples shows a configuration with the new automatic selection of the baud rate
by measuring the rate of the first incoming data.
The flashing of the LED at the program start is deselected in the first example to save flash memory.

\begin{verbatim}
optiboot $ make atmega328p LED_START_FLASHES=0 BAUD_RATE=52

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin not used!
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=52 -DLED_START_FLASHES=0 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
Simple Baudrate measurement with time limit implemented in optiboot! (4-bit, CLK/8)
UART Minimum 976 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    500       0       0     500     1f4 optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}


for the last example the most complex methode of baud rate measurement
was selected because the limit of 512 byte would be exceeded with
selecting the LED flashing and the simplest measurement method (534 byte).

\begin{verbatim}
optiboot $ make atmega328p BAUD_RATE=76

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=82 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
Complex Baudrate measurement implemented in optiboot! (4-bit, CLK/1)
UART Minimum 2197 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7C00 = 31744
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    612       0       0     612     264 optiboot.elf
Requires 2 Boot Pages, 512 Bytes each, which is 3.1% of Flash Memory
BOOTSZ=2, which means 2 Boot Pages

\end{verbatim}


\section{Clock Frequency Correction of the internal RC-Generator}

The use of the serial interface is only possible, if the selected baudrate is
matched by both interfaces with only two percent deviation.
The actual baudrate is given by the processor clock and the selected scaling factor for
the serial IO-clock. 
The hardware UART interface scaled the processor clock with factor 8 or 16 and a
additional selectable divider between 1:1 and 1:4096 for generating the clock
for the serial IO.
For lower baudrates additional dividers with power of 2 can be additional selected.
If the relationship between the processor clock and the baudrate clock is
sufficiently high, the desired baudrate can be selected with low deviation.
By generating the optiboot bootloader code the systematic error is shown
at the terminal protocol.
Usually errors lower than 2\% are uncritical.
The implemented coding of the serial interface with software (SOFT\_UART) produce
lower systematic errors as the hardware UART.
The problems with the software solution of the serial interface is caused with
no filter for input data and the missing feature to organize the interface
full duplex. From the output of the last bit to the ability to receive
the next data is allways a little time delay.
For this reason you can expect fewer difficulties with lower baudrates for
the software UART.
All this considerations assume however, that the processor clock itself is
selected with sufficient accuracy.
With a crystal or ceramic resonator the clock frequency is usually accurate enough
without special activities. But for the internal RC-generator of the AVR processors
the situation is different.
The actual processor clock can differ too much from the desired value.
The processors are precalibrated at factory. But this calibration is
valid only for one temperature and operating voltage.
The sensivity of frequency changes with temperature and operating voltage
differ for the different processor types.
To enable a correction for the user of the processor, the calibration value
of the clock frequency is copied to a special IO register with the name OSCCAL
at every start of the processor.
The Optiboot bootloader can use the option OSCCAL\_CORR to correct a
known residual error of the clock frequency.

If the actual clock rate is uncritical for your application and you
can spend the additional memory space to the bootloader,
you can also use the automatic baud rate selection of optiboot.
The automatic baud rate selection is implemented by the optiboot bootloader,
if you select a baud rate below 100 at the generation time.
You can find more details about the automatic baud rate selection in
subsection~\ref{sec:autobaud} at page~\pageref{sec:autobaud}.
But you should keep in mind, that the deviation to the expected clock rate
will also affect the application program ( if it will use a serial interface).

In the following subsections I have analysed the correction of the
RC clock frequency for some AVR examples.


\subsection{RC-generators check of the ATmega8}

The Atmega8 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In the table~\ref{tab:mega8freq} I have analysed all 4 selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -8  & 1050k &  4  & 983k  & 0  & 1004k \\
    \hline
                2M & 0xA2  & 19.2k &  -8  & 2098k &  4  & 1967k & 0  & 2008k \\
    \hline
                4M & 0xA3  & 19.2k &  -2  & 4201k & 10  & 3927k & 7  & 3999k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8231k & 13  & 7723k & 6  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8}
  \label{tab:mega8freq}
\end{table}

The table~\ref{tab:mega8freq} shows, that for the \(1Mhz\) and \(2MHz\) operation a correction of the
OSCCAL register is not required. This ATmega8 is calibrated for these frequencies
very good at the factory.
For the \(4MHz\) clock frequency a operation without correction is still possible,
but the correct clock frequency is better approximated with a OSCCAL\_CORR value of 7.
For the \(8MHz\) clock frequency the serial interface was still possible
withou the correction, but the serial interface runs more safely with
the OSCCAL\_CORR value 6.

\subsection{RC-Generators check of the ATmega8535}

The ATmega8535 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8535freq} shows the results for one example for
all 4 frequencies.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  3  & 982k  & 0  & 1001k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2095k &  4  & 1965k & 1  & 1998k \\
    \hline
                4M & 0xA3  & 19.2k &  -5  & 4204k &  8  & 3932k & 4  & 4012k \\
    \hline
                8M & 0xA4  & 19.2k &  -7  & 8420k &  6  & 7901k & 3  & 8003k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8535}
  \label{tab:mega8535freq}
\end{table}

\subsection{RC-Generators check of the ATmega8515 and the ATmega162}

The ATmega8515 can select 4 different frequencies for the internal RC generator
with the Low fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8515freq} shows the results of one exemplar 
for all 4 frequency selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  2  & 985k  & -1  & 997k \\
    \hline
                2M & 0xA2  & 19.2k &  -10  & 2099k &  3  & 1963k & -1  & 1999k \\
    \hline
                4M & 0xA3  & 38.4k &  -3  & 4192k &  10  & 3928k & 7  & 3979k \\
    \hline
                8M & 0xA4  & 38.4k &  -3  & 8396k &  10  & 7860k & 7  & 7966k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8515}
  \label{tab:mega8515freq}
\end{table}

The ATmega162 with a simular pin layout can only operate with the
\(8MHz\) RC generator frequency.
Table~\ref{tab:mega162freq} shows the result of one exemplar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                8M & 0xE2  & 38.4k &  0  & 8190k &   6  & 7718k & 2  & 8000k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-oscillator of the ATmega162}
  \label{tab:mega162freq}
\end{table}


\subsection{RC-Generators check of the ATmega328 family}

For the ATmega328 family only a RC oscillator frequency of \(8MHz\) can be selected.
This Frequency can be divided by factor 8 with a fuse-bit, so that a
operation with \(1MHz\) can be also selected.
The table~\ref{tab:mega328freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
    Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega48P &          8M & 0xE2  & 57.6k &  -6  & 8230k &  8  & 7720k  & 0  & 8010k \\
    \hline
mega88 &          8M & 0xE2  & 57.6k &  -2  & 8250k & 10  & 7770k  & 4  & 7990k \\
    \hline
mega168 &          8M & 0xE2  & 57.6k &  -5  & 8263k &  8  & 7720k  & 1  & 7970k \\
    \hline
mega328P &          8M & 0xE2  & 57.6k &  -5  & 8250k &  9  & 7723k  & 1  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega328 family}
  \label{tab:mega328freq}
\end{table}

For all checked processors the serial interface can be used with the internal
RC generator without any OSCCAL correction.
Only for the checked ATmega88 a correction would be worthwhile (OSCCAL\_CORR=4).

\subsection{RC-Generators check of the ATmega32 / 16}

You can select 4 different frequencies with the internal RC-generator for
the ATmega32 and the ATmega16, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The tables~\ref{tab:mega32freq} and \ref{tab:mega16freq} shows the results
with one test exemplar each.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c || c | c || c | c || c | c |}
    \hline
       & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
 Typ    &     FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
m32  &       1M    & 0xA1  &  9.6k &  -13  & 1049k & -1  & 980k  & -5  & 1001k \\
m32a &             &       &       &  -7  & 1046k &  4  & 984k  & 1  & 998k \\
    \hline
m32  &       2M    & 0xA2  & 19.2k &  -12  & 2102k &  0  & 1968k & -3  & 1997k \\
m32a &             &       &       &  -7  & 2105k &  6  & 1966k & 2  & 2005k \\
    \hline
m32  &       4M    & 0xA3  & 19.2k &  -5  & 4169k & 6  & 3942k & 3  & 3993k \\
m32a &             &       &       &   2  & 4192k & 14  & 3939k & 10  & 4015k \\
    \hline
m32  &       8M    & 0xA4  & 19.2k &  -7  & 8425k &  6  & 7888k & 3  & 7983k \\
m32a &             &       &       &   2  & 8408k & 14  & 7921k & 11  & 8014k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega32}
  \label{tab:mega32freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -11  & 1047k &  1  & 982k  & -2  & 998k \\
    \hline
                2M & 0xA2  & 19.2k &  -12  & 2099k &  0  & 1971k & -3 & 1995k \\
    \hline
                4M & 0xA3  & 19.2k &  -9  & 4291k &  3  & 3932k & 0  & 4002k \\
    \hline
                8M & 0xA4  & 19.2k &  -11 & 8415k & 2  & 7857k & -2  & 8013k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega16}
  \label{tab:mega16freq}
\end{table}

Whenever positive values appear in the MinCorr column or negative values in the MaxCorr
column, it is impossible to use the serial interface with this processor at this frequency 
without a frequency correction.
If a 0 appear in any of the Corr columns, the operation of the serial interface
is just possible.

\subsection{RC-Generator check of the ATmega163L}

The ATmega163L has only one \(1MHz\) RC-generator, which can be adjusted
with the OSCCAL register.
My exemplar had no preselection of the OSCCAL value.
Therefore, exceptiionally high correction values are required to select
a clock frequency of about \(1MHz\).

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0x92  &  9.6k &  -88  & 1026k &  -62  & 964k  & -77  &  998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequency of the ATmega163L}
  \label{tab:mega163freq}
\end{table}

\subsection{RC-Generator check of the ATmega64 / 128}

The ATmega64 and the ATmega128 can select 4 different frequencies for the
internal RC-generator with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In then tables~\ref{tab:mega64freq} and \ref{tab:mega128freq} all 4 frequencies
are checked.
At this point it should also be noticed, that the program data is loaded via the ISP
interface not with the signals MISO and MOSI but via the signals TXD (PE1) and
RXD (PE0). Of course this must be taken into account when connecting the
processor to the programmer.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -4  & 1024k &  6  & 975k  & 1  & 1000k \\
    \hline
                2M & 0xA2  & 19.2k &  -4  & 2047k &  6  & 1952k & 0  & 2015k \\
    \hline
                4M & 0xA3  & 19.2k &   4  & 4070k & 10  & 3939k & 8  & 3976k \\
    \hline
                8M & 0xA4  & 57.6k &   6  & 8028k & 10  & 7847k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega64}
  \label{tab:mega64freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -9  & 1051k &  3  & 985k  & 0  &  999k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2102k &  3  & 1971k & 0  & 2000k \\
    \hline
                4M & 0xA3  & 19.2k &  -3  & 4209k &  9  & 3960k & 6  & 4006k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8225k & 13  & 7723k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega128}
  \label{tab:mega128freq}
\end{table}

You can see at the tables, that there is no correction of the OSCCAL register necessary 
at \(1MHz\) and \(2MHz\) operation for using the serial interface.
For operation at \(4MHz\) or \(8MHz\) the checked ATmega64 can not use
the serial interface without a frequency correction.
The \(4MHz\) frequency is about 4\% too high Without the correction and
the \(8MHz\) frequency is about 4.3\% too high.
You can find a hint in the Atmel documentation, that the RC-generator of the
ATmega64 and ATmega128 is calibrated at \(1MHz\).
It should be noted once again, that the the tabular data is the test result of a single copy
of the ATmega. Outside the specified minimum or maximum values of the OSCCAL-corrections,
it was not possible to operate the serial interface at thespecified baud rate.

\subsection{RC-Generator check of the ATmega644 family}

For the ATmega644 family an RC oscillator frequency of \(8MHz\) can be selected.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega644freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1284p &          8M & 0xC2  & 19.2k & -8  & 8416k & 7  & 7882k  & 4  & 7989k \\
    \hline
mega644p &          8M & 0xC2  & 19.2k &  -12 & 8416k & 3  & 7871k  & -1  & 8009k \\
    \hline
mega324p &          8M & 0xC2  & 19.2k &  -12 & 8398k & 3  & 7885k  & 0  & 7976k \\
    \hline
mega164p &          8M & 0xC2  & 19.2k &  -5  & 8401k & 4  & 7888k  & 2  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega644 family}
  \label{tab:mega644freq}
\end{table}

\subsection{RC-Generator check of the ATmega645 family}

For the ATmega645 family an RC oscillator frequency of \(8MHz\) can be selected.
Bei der ATmega645 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gewählt werden.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega645freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega165p &         8M & 0xE2  & 57.6k & -6  & 8235k &  7  & 7718k  & -1  & 8015k \\
    \hline
mega325  &         8M & 0xE2  & 38.4k & -10 & 8403k &  5  & 7868k  &  1  & 7992k \\
    \hline
mega645 &          8M & 0xE2  & 57.6k &  0  & 8253k & 12  & 7726k  & 5  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega645 family}
  \label{tab:mega645freq}
\end{table}

Beim ATmega645 ist der Betrieb der seriellen Schnittstelle ohne OSCCAL Korrektur gerade noch möglich.
Sicherer ist aber der Betrieb mit OSCCAL\_CORR=5, da dann die 8MHz besser eingehalten werden. 

\subsection{RC-Generator check of the ATmega649 family}

For the ATmega649 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega649freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega169 &          8M & 0xE2  & 57.6k &  -9  & 8250k & 2  & 7864k  & -2  & 8010k \\
    \hline
mega329 &          8M & 0xE2  & 38.4k &  -2  & 8330k & 7  & 7877k  &  4  & 8013k \\
    \hline
mega649 &          8M & 0xE2  & 38.4k &  -2  & 8370k & 8  & 7895k  &  6  & 7988k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega649 family}
  \label{tab:mega649freq}
\end{table}

\subsection{RC-Generator check of the ATmega2560 family}

For the ATmega2560 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega2560freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1281 &          8M & 0xC2  & 38.4k &  -5 & 8405k & 5 & 7871k   & 2  &  8012k \\
    \hline
mega2561 &          8M & 0xC2  & 38.4k &  -8 & 8363k & 4  & 7870k  & 1  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega2560 family}
  \label{tab:mega2560freq}
\end{table}

Loading of more than 128Kbyte data was successfully tested with the ATmega2561.
Normally the user data for the flash memory starts withh the address 0.
This is not absolutely nessesary for data download via the serial interface.
But the initial address must be below 128K (0x20000), so that the loading
of data into the upper flash memory half works.
The option VIRTUAL\_BOOT\_PARTITION can not be used by processors with
more than 128Kbyte flash memory.

\subsection{RC-Generator check of the ATtiny4313 family}

The ATtiny4313 und the ATtiny2313 can select a RC-generator frequency of
\(8MHz\) and \(4MHz\) with the Low-fuse.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The table~\ref{tab:tiny4313freq} shows the results of the frequeny measurement
at \(4MHz\) and \(8MHz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
tiny4313 &         8M & 0xE4  & 38.4k &  -4  & 8342k & 0  & 7975k  & -1  & 7983k \\
         &            &       &       &  -2  & 8326k & 3  & 7905k  & 1  & 8010k \\
    \hline
tiny2313 &         8M & 0xE4  & 38.4k &  -4  & 8400k & 3  & 7909k  &  2  & 7980k \\
    \hline
tiny4313 &         4M & 0xE2  & 38.4k &  -6  & 4193k & -3  & 3976k  & -3  & 3976k \\
         &            &       &       &   1  & 4169k & 6  & 3961k  & 5  & 4017k \\
    \hline
tiny2313 &         4M & 0xE2  & 38.4k &   0  & 4160k & 6  & 3960k  &  5  & 3998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny4313 family}
  \label{tab:tiny4313freq}
\end{table}

For all three checked ATtinys of this series the setting of the frequency was difficult
because a small OSCCAL correction results to a relatively strong frequency change.


\subsection{RC-Generator check of the ATtiny84 family}

The ATtiny84 family can select the \(128kHz\) clock of the watch dog additional
to the \(8MHz\) internal RC-generator as the main clock.
But the \(128kHz\) clock can not be adjusted. If you use this clock,
you can only correct the generated baud rate by selecting another baud rate value
or you can use the automatic baud rate selection.
For a ATtiny24a I have checked the generated baud rate. Instead of the selected
2400 Baud I could measure only 2170 Baud.
This results to a frequency error of about 9.6\%, which is much too high for
using it without a correction.
If I select a baud rate of 2640 Baud for the optiboot, the download could operate with 
2400 Baud. The measured clock frequency of the processor was \(115.2kHz\) instead
of the \(128kHz\).
The table~\ref{tab:tiny84freq} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny84 &          8M & 0xE2  & 19.2k &  -6  & 8453k & 14  & 7673k  & 5  & 8019k \\
    \hline
attiny44a &         8M & 0xE2  & 19.2k &  -16  & 8367k & 3  & 7673k  & -7  & 7984k \\
    \hline
attiny24a &         8M & 0xE2  & 19.2k &  -4  & 8388k & 11  & 7685k  & 4  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny84 family}
  \label{tab:tiny84freq}
\end{table}

\subsection{RC-Generators check of the ATtiny85 family}

The ATtiny84 family can select a \(8MHz\) and a \(6.4MHz\) RC-generator and
a \(128kHz\) clock of the watchdog circuit.
The \(6.4MHz\) RC-generator clock is allways scaled to \(1.6Mhz\) for
the processor clock.
The \(128kHz\) clock can not be calibrated. If you wish to use this clock,
you can adjust the baud rate only by selecting a corrected baud rate value
or you can use the automatic baud rate selection.
The first table~\ref{tab:tiny85freq8} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &          8M & 0xE2  & 38.4k &  -4  & 8370k &  9  & 7714k  & 3  & 8012k \\
    \hline
attiny45  &         8M & 0xE2  & 38.4k &  -4  & 8400k & 9  & 7706k  & 3  & 8030k \\
    \hline
attiny25  &         8M & 0xE2  & 38.4k &  -9  & 8424k & 46  & 7724k  & 40  & 8034k \\
attiny25  &         8M & 0xE2  & 38.4k &  -12  & 8399k & 7  & 7680k  & -2  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(8MHz\) operation}
  \label{tab:tiny85freq8}
\end{table}

The setting values for the ATtiny25 look strange, but in the case of correction 3
the OSCCAL value has fallen below the number 128 and is therefore in a different
setting range.
Not before a correction value of 34 a frequency of \(8364kHz\) was reached again,
at which a operation of the serial interface was possible.
A simular frequency could be selected with the correction value -6 in the other
setting range.
The next table~\ref{tab:tiny85freq1} shows the results of the frequeny measurement
at the \(1.6Mhz\) operation for the checked processors.
The RC-generator operates at \(6.4Mhz\), but this frequency is allways divided
ba factor 4 for the processor.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xD3  & 9.6k &  -7  & 1684k &  9  & 1547k  & 2  & 1603k \\
    \hline
attiny45  &        1.6M & 0xD3  & 9.6k &  -5  & 1684k & 11  & 1559k  & 4  & 1603k \\
    \hline
attiny25  &        1.6M & 0xD3  & 9.6k &  -7   & 1689k & 10 & 1543k  & 3  & 1602k \\
attiny25  &        1.6M & 0xD3  & 9.6k &  -10  & 1680k & 3  & 1550k  & -3  & 1609k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(1.6MHz\) operation}
  \label{tab:tiny85freq1}
\end{table}

The operation with \(1.6MHz\) clock frequency has not shown the anomaly of the
OSCCAL setting for the ATtiny25.
All checked examples can use the serial interface without any correction
at this frequency.
The ATtiny84 processor family can also use a PLL-oscillator, which is controlled
with the internal \(8MHz\) RC generator. The PLL-oscillator can operate at
\(64MHz\) or at \(32MHz\) clock, which is typically used for the T1 counter.
If you use the PLL-clock for the processor, you can only select the \(64MHz\) operation
and the clock is scaled by factor 4. So you will get a resulting \(16MHz\) clock
for the processor.
The table~\ref{tab:tiny85freq16} shows the measured results.
As expected, these results do not differ significantly from the \(8MHz\) results.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         16M & 0xF1  & 38.4k &  -4  & 16.87M &  10  & 15.41M  & 4  & 16.02M \\
    \hline
attiny45  &        16M & 0xF1  & 38.4k &  -4  & 16.87M & 10  & 15.41M  & 4  & 15.95M \\
    \hline
attiny25  &        16M & 0xF1  & 38.4k &  -9   & 16.91M & 47 & 15.38M  & 41  & 16.03M \\
attiny25  &        16M & 0xF1  & 38.4k &  -11  & 16.82M & 7  & 15.43M  & -2  & 16.07M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(16MHz\) operation}
  \label{tab:tiny85freq16}
\end{table}

\subsection{RC-Generators check of the ATtiny841 family}

The ATtiny841 and the ATtiny441 can use also a internal \(8MHz\) RC-generator,
which can be adjusted.
For the support of this family some special modifications must be done
at the optiboot bootloader source.
The table~\ref{tab:tiny841freq8} shows the results of some checked examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny841 &          8M & 0xE2  & 38.4k &  -4  & 8369k & 10  & 7861k  & 6  & 8003k \\
          &             &       &       &  -5  & 8389k &  9  & 7874k  & 6  & 7990k \\
    \hline
attiny441  &         8M & 0xE2  & 38.4k &  -4  & 8399k & 10 & 7870k  & 7  & 7985k \\
           &            &       &       &  -4  & 8380k &  9 & 7900k  & 7  & 7985k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny841 family at \(8MHz\) operation}
  \label{tab:tiny841freq8}
\end{table}

For all checked examples the serial interface can be used without the
OSCCAL correction.


\subsection{RC-Generators check of the ATtiny861 family}

The ATtiny861 family can use a \(8MHz\) internal RC generator, a PLL oscillator
and the \(128kHz\) clock of the watchdog circuit.
The \(128kHz\) clock of the watchdog circuit can not be calibrated und is
therefore limited for use with the bootloader application.
The PLL-Oscillator has a resulting frequency of \(16MHz\) for the processor,
which can only synchronized by the internal RC-generator.
Therefore you can not use the PLL-oscillator with the T1 counter
for precise time measurements.
The first table~\ref{tab:tiny861freq8} shows the OSCCAL correction results of the checked examples
for the \(8MHz\) operation.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny861 &          8M & 0xE2  & 38.4k &  -2  & 8415k & 18  & 7693k  & 9  & 8007k \\
          &             &       &       &  -1  & 8436k & 19  & 7678k  & 10 & 8011k \\
    \hline
attiny461  &         8M & 0xE2  & 38.4k &  -2  & 8418k & 17 & 7690k  & 9  & 7995k \\
           &            &       &       &  -4  & 8380k & 14 & 7695k  & 5  & 8030k \\
    \hline
attiny261  &         8M & 0xE2  & 38.4k &  -4  & 8403k & 17 & 7710k  & 9  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny861 family at \(8MHz\) operation}
  \label{tab:tiny861freq8}
\end{table}

For the ATtiny261 I have omitted the optional LED-flashing at the start of the optiboot
to get enough space for the test program (option LED\_START\_FLASHES=0).


\subsection{RC-Generators check of the ATtiny87 family}

The ATtiny87 family can select a internal \(8MHz\) RC-generator and a
internal \(128kHz\) generator as processor clock.
You can also select a factor 8 scaler for the processor clock with the Low-fuse.
The table~\ref{tab:tiny87freq} shows the calibration results of two examples of this family.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny87 &          8M & 0xE2  & 57.6k &  -1  & 8270k & 7  & 7940k  & 3  & 8035k \\
    \hline
attiny167 &         8M & 0xE2  & 57.6k &  -5  & 8227k & 2  & 7839k  & -1  & 8009k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny87 family}
  \label{tab:tiny87freq}
\end{table}


\subsection{RC-Generators check of the ATtiny88 family}

The ATtiny88 family can select a internal \(8MHz\) RC-generator and a
internal \(128kHz\) generator as processor clock.
You can also select a factor 8 scaler for the processor clock with the Low-fuse.
The table~\ref{tab:tiny88freq} shows the calibration results of two examples of this family.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny88 &          8M & 0xE2  & 38.4k &  -4  & 8397k & 15  & 7682k  & 6  & 8013k \\
    \hline
attiny48 &         8M & 0xE2  & 38.4k &  -5  & 8385k & 12  & 7739k  & 5  & 7995k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny88 family}
  \label{tab:tiny88freq}
\end{table}

Both examples can operate the serial interface without a frequency correction.
But the processor clock will match the \(8MHz\) better, if you choose
a correction value of 5 (6).

\subsection{RC-Generator check of the ATtiny1634}

I have checked the \(8MHz\) internal RC-generator of the ATtiny1634
with two examples.
The ATtiny1634 support two additional calibration register for adjusting the
temperature drift of the \(8MHz\) RC-generator.
In the table~\ref{tab:tiny1634freq} I have not checked the effect of
the temperature drift compensation.
Additional to the \(8MHz\) RC-generator the ATmega1634 can also adjust
the internal \(32kHz\) generator with a additional calibration register (OSCCAL1).
This adjustment is currently unsupported by the Optiboot bootloader.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
         8M & 0xE2  & 19.2k &  -5  & 8404k &  9  & 7867k  & 6  & 7983k \\
         8M & 0xE2  & 19.2k &  -7  & 8410k &  7  & 7867k  & 4  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny1634}
  \label{tab:tiny1634freq}
\end{table}

\subsection{RC-Generators check of the AT90PWM family}

Beside the usual \(8MHz\) internal RC-generator the AT90PWM family can also
select a PLL-oscillator with a resulting processor clock of \(16MHz\).
The PLL-oscillator is synchronized by the internal \(8MHz\) RC-generator.
The table~\ref{tab:t90pwmfreq} shows the OSCCAL correction results
of two examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90pwm2b &         8M & 0xE2  & 38.4k &  -13  & 8350k & -1  & 7862k  & -5  & 8020k \\
    \hline
at90pwm3  &         8M & 0xE2  & 38.4k &  -10  & 8359k &  4  & 7885k  & 1  & 7991k \\
    \hline
at90pwm2b &        16M & 0xE3  & 38.4k &  -14  & 16.74M & -1  & 15.74M  & -4  & 15.97M \\
    \hline
at90pwm3  &        16M & 0xE3  & 38.4k &  -10  & 16.79M &  4  & 15.79M  & 2  & 15.97M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the AT90PWM family}
  \label{tab:t90pwmfreq}
\end{table}

The AT90PWM2B can not use the serial interface without a OSCCAL correction.

\subsection{RC-Generators check of the AT90CAN family}

I have examined only one copy of a AT90CAN32 and AT90CAN132.
Both AT90CAN examples can only select one internal \(8~MHz\) RC-oscillator.
All other choises require an external crystal or external clock generator.
The clock frequency can optionally be divided by the factor 8,
so that also a \(1~MHz\) operation is possible with the internal clock.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90can32 &         8M & 0xE2  & 38.4k &  0  & 8379k & 6  & 7920k  & 5  & 8019k \\
    \hline
at90can128 &         8M & 0xE2  & 38.4k &  0  & 8303k &  3  & 7922k  & 2  & 8057k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the AT90CAN family}
  \label{tab:t90canfreq}
\end{table}


\section{Examination of the cooperation with USB-serial converters}

\subsection{Preface to the test environment}
At first the environment for the series tests of the behavior of automatic baud rate adjustment
are bad. The baud rate of the AVR-UART interface can be selected only with great steps for
higher baud rates. Also the choise of baud rates for the different USB-serial chips is limited
by the chip and the capability of the driver.
With the AVR processors it is possible to detune the clock frequency of the local RC generator
with OSCCAL, but the result of the detuning vary with each particular model.
The resulting oscillating frequency of the local RC generator can be measured,
but the step size of the detuning cannot be changed to get a specific frequency exactly.
I know only one way out of this difficulty is to use a external clock source for the AVR processor.
For this reason I got the relatively inexpensive Kkmoon FY6900 function generator,
which can generate almost any waveform with frequencies up to 60 MHz.
Of course, this function generator can also generate square-wave signals, which can serve as
a clock for the AVR.
The function generator can be operated both via the front panel and via a USB interface.
The USB interface consists of an internal CH341 USB-serial converter, so that no special USB driver is required.
The control can be done with well-documented ASCII character strings.
iThis fulfills the essential requirements for systematic tests of the interaction between avrdude,
the USB-serial converter and the optiboot bootloader.
In particular, the behavior of the automatic baud rate adjustment should be examined more intensively.
For this, downloads with avrdude should be repeated with different clock frequencies,
so that problems are detected.
I choosed a number of 40 repititions as a acceptable compromise between expenditure of time and
statistical significance.
Since 41 different frequencies are to be examined with the automatic baud rate adjustment,
there are already 1640 write processes for one variant.
With more than 10 of these variants, the guaranteed number of cycles of the AVR flash memory would be exceeded.
Since I didn't want to examine the cycle stability of the AVR flash memory,
I provided a write protection pin in the optiboot software for this.
This additional function of optiboot is only useful for these examinations, therefore this
option (WRITE\_PROTECT\_PIN) is not further documented.

\subsection{Autobaud measurements with different USB-Serial chips}

The data for the results presented here were generated with the bash script file test\_download
in the subdirectory ee\_test and then combined in .tab files in the directory Doku/results with an editor.
In the course of the investigations, an improvement in the baud rate measurement with the divided clock frequency
could be built into optiboot.
The improvement consists of resetting the prescaler for the AVR's counters.
The other source of error for the time measurement is caused by the query loop for the RX data pin and
results to at least 3 clocks for each measuring point.
But first I will show the count of errors with different USB-serial chips with 40 downloads for
each clock frequency between 14 MHz and 18 MHz with a step size of 100 kHz and a baud rate of 115200.
A total of 1640 downloads of 10 kByte with avrdude was the base for each table entry.
A special modified avrdude program was used for these tests,
which can select a serial output with two stop bits with the new parameter -S.
The differences of the avrdude sources are notices in the file ee\_test/avrdude.diff.


\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c || c | c | c | c | c | c | c | c | }
    \hline
          & FT232 & FT232 & CH340 & CP2102 & CP2104 & PL2303 & Pololu & Arduino \\
 Baud rate & RL    & Clone &       &        &       & TA     & AVR    & UNO     \\
    \hline
    \hline
    22    &  0    &  1    &  40   &   0    &   0    &  0     &  264   &   0    \\
    26    &  0    &  0    &  69   &   0    &   0    &  0     &  250   &   0    \\
    62    &  150  &  181  &  186  &   95   &   155  &  145   &  521   &   129  \\
    \hline
    32    &  0    &  0    &  72   &   0    &   0    &  0     &  217   &   0    \\
    36    &  0    &  0    &  12   &   0    &   0    &  0     &  261   &   0    \\
    72    &  10   &  44   &  24   &   4    &   4    &  3     &  427   &   0    \\
    76    &  1    &  0    &  2    &   0    &   0    &  0     &  331   &   0    \\
    \hline
    12    &  0    &  0    &  7    &   0    &   0    &  0     &  281   &   0    \\
    82    &  0    &  0    &  7    &   0    &   0    &  0     &  285   &   0    \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Error rate of 1640 downloads with 10 kByte each using the HW-UART}
  \label{tab:HWautoErrs}
\end{table}

As a reminder, the key for the Optiboot auto baud rate setting should be mentioned here.
Settings 22, 26 and 62 all select a 2-bit time measurement.
With settings 22 and 62 the counter, which is used for the time measuring,
works with /8 frequency prescaler,
only with setting 26 the counter runs at full clock rate.\\

Correspondingly, the settings 32, 36, 72 and 76 select a 4-bit time measurement.
With settings 32 and 72 a counter with /8 frequency prescaler is used,
settings 36 and 76 use a counter without prescaler for the time measurement.
The other two settings 12 and 82 use 9 bits for time measurement,
both with the /8 prescaler for the counter.\\

The other two settings 12 and 82 use 9 bits for time measurement,
both with the /8 prescaler for the counter. \\

The USB-serial converter FT232 appears twice in the table \ref{tab:HWautoErrs}, once as FT232RL,s
the original chip from Future Technology Devices International Limited (FTDI) and once as FT232clone,
a Chinese replica of unknown origin with the serial number A50285BI.
The replicas usually have the same serial number. The original chips all have a different serial number.
From the outside, the replicated chips are difficult to identify because the manufacturer's logo FTDI was copied also.
The examined Chinese replica achieved similarly good test results as the original chips. \\

You can see in the table \ref{tab:HWautoErrs}, that the number of errors in the autobaud settings 62, 72 and 82 are noticeably high.
The reason is that the counter with the /8 prescaler for the additional checks is already started with the start bit of
the serial receive data and the state is further only read for the time measurement.

As a result, the condition of the prescaler during the actual time measurement is undefined.
With settings 22 and 32, the counter is started with a prescaler reset with the first data bit used for measurement.
As a result, the time measurement gains measurement reliability.
Settings 26, 36 and 76 use the counter without a prescaler and therefore 
the problem with the undefined prescaler does not exist here.
I would like to mention here that earlier versions of the optiboot autobaud measurement with settings 22 and 32
would result to simular high error rates as the settings 62 and 72, because the prescaler was never reset.
With normal use, you can expect fewer problems with autobaud than with this tests,
because the clock frequency of the AVR is better suited to the desired baud rate.
The tests here are designed to show the limits of the automatic baud rate adjustment. \\

Two USB-serial converters stand out in the table \ref{tab:HWautoErrs} with a higher error rate,
the CH340 and the Pololu AVR.
In order to detect the reason, further measurements were made with a fixed UBBR divider,
which are shown in the next subsection.

\subsection{Measurement of USB-serial converters mit fixed optiboot baud rate}
For this tests, the optiboot baud rate was fixed to 115200
at a clock rate of 16 MHz.
The USB-serial converters speed is always set to 115200 baud.
The clock frequency of the ATmega has been increased from 14.7 MHz in 100 kHz steps
to 17.1 MHz instead of the fixed 16 MHz.
The optiboot baud rate changes proportionally with the change in frequency.
For the tests downloads of 10 kByte each with avrdude are repested 40 times for each frequency.
The number of unsuccessful attempts for each frequency are recorded in a table from the script file test\_download.
From the tables obtained in this way for the various USB-serial converters, an editor was used to create
an overall table for the test series with 1 stop bit (Doku/results/HWfix\_1\_115200\_USBserial\_0.tab)
and for the test series with 2 stop bits (Doku/results/HWfix\_1\_115200\_USBserial\_1.tab).
The table \ref{tab:HWfixErrs} was then created from these tables.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c || c | c | c || c | c | c |}
    \hline
              & \multicolumn{3}{c ||}{115200 Baud, 2 Stop Bits} & \multicolumn{3}{c |}{115200 Baud, 1 Stop Bit} \\
    USB-Seriell  & Mindest- & Maximal- & Frequenz- & Mindest- & Maximal- & Frequenz- \\
    Typ          & Frequenz & Frequenz & Bereich   & Frequenz & Frequenz & Bereich \\
    \hline
    FT232RL      & 15.1 MHz & 16.5 MHz & 9.3\%     & 15.4 MHz & 16.5 MHz & 7.9\% \\
    FT232clone   & 15.2 MHz & 16.5 MHz & 8.7\%     & 15.5 MHz & 16.5 MHz & 7.2\% \\
    CH340G       & 15.1 MHz & 16.1 MHz & 6.8\%     & 15.4 MHz & 16.1 MHz & 5.0\% \\
    CP2102       & 15.0 MHz & 16.4 MHz & 9.3\%     & 15.3 MHz & 16.4 MHz & 7.5\% \\
    CP2104       & 15.1 MHz & 16.6 MHz & 10\%      & 15.3 MHz & 16.6 MHz & 8.6\% \\
    PL2303TA     & 15.1 MHz & 16.6 MHz & 10\%      & 15.1 MHz & 16.6 MHz & 10\% \\
    PololuAVR    & 15.4 MHz & 16.5 MHz & 7.5\%     & 15.4 MHz & 16.5 MHz & 7.5\% \\
    ArduinoUNO   & 15.4 MHz & 16.6 MHz & 8.1\%     & 15.7 MHz & 16.6 MHz & 6.2\% \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Usable clock frequency range with Hardware-UART}
  \label{tab:HWfixErrs}
\end{table}

A permissible deviation of the baud rate of $\pm 4\%$ was expected with this tests,
resulting to a total area of 8\%.
Only two USB-serial converters, the CP2104 and the PL2303TA, match to the expected 8\% area with
the normal 1 stop bit operation.
With 2 stop bits selected for the serial interface, the FT232 converters, the CP2102, CP2104 and PL2303TA converters
as well as the Arduino UNO reach the expected 8\% range.
The CH340G converter significantly improves the usable area to 6.8\%, but remains below 8\%.
The PololuAVR and the PL2303TA shows no reaction to increasing the number of stop bits from 1 to 2.
But the time measurement with the Linux command ''time'' of the output of more than 10000 characters 
results to about 10\% more time usage with the selection of 2 stop bits instead of 1 stop bit.
The PololuAVR does not show any significant time change with this test.
So I assume,  that the interaction between driver and chip does not work with the PololuAVR.\\

In any case, the possible cause for the poor performance of the CH340G chip and the PololuAVR 
in table \ref{tab:HWautoErrs} on page \pageref{tab:HWautoErrs} is found.
With the PololuAVR you should consider that it is designed as an ISP programmer
and the USB-serial converter is only an additional function.\\
The clear front runners in this special comparative test are the CP2104 from Silicon Laboratories Inc. and
the PL2303TA from Prolific Technology Inc. ,
which also achieved better values in this test than the FT232RL from Future Technology Devices International.
According to the data sheet, the FT232RL supports a maximum baud rate of 3 Mbaud,
the PL2303TA even 6 Mbaud,
which neither the CP2102 (1 Mbaud) nor the test winner CP2104 (2 Mbaud) can achieve according to the data sheet.\\

In addition, I also examined the work area of the USB-serial converter in conjunction with the
software UART solution from optiboot.
The software uses about 1.5 stop bits when sending data,
the USB-serial converters use either 1 (Doku/results/SWfix\_1\_115200\_USBserial\_0.tab) or
2 stop bits (Doku/results/SWfix\_1\_115200\_USBserial\_0.tab).
The results are summarized in the table \ref{tab:SWfixErrs}.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c || c | c | c || c | c | c |}
    \hline
              & \multicolumn{3}{c ||}{115200 Baud, 2 Stop Bits} & \multicolumn{3}{c |}{115200 Baud, 1 Stop Bit} \\
    USB-Seriell  & Minimum- & Maximum- & Frequency- & Minimum- & Maximum- & Frequency- \\
    Typ          & Frequency & Frequency & area   & Frequency & Frequency & area \\
    \hline
    FT232RL      & 15.3 MHz & 16.8 MHz & 9.8\%     & 15.5 MHz & 16.8 MHz & 8.7\% \\
    FT232clone   & 15.4 MHz & 16.9 MHz & 9.8\%     & 15.55 MHz & 16.9 MHz & 9.0\% \\
    CH340G       & 15.2 MHz & 16.5 MHz & 8.5\%     & 15.5 MHz & 16.5 MHz & 6.8\% \\
    CP2102       & 15.2 MHz & 16.7 MHz & 10\%      & 15.5 MHz & 16.8 MHz & 8.7\% \\
    CP2104       & 15.2 MHz & 16.9 MHz & 11.2\%    & 15.3 MHz & 16.9 MHz & 10.6\% \\
    PL2303TA     & 15.3 MHz & 16.9 MHz & 10.6\%    & 15.4 MHz & 16.9 MHz & 10\% \\
    PololuAVR    & 15.5 MHz & 16.9 MHz & 9.3\%     & 15.5 MHz & 16.9 MHz & 9.3\% \\
    ArduinoUNO   & 15.4 MHz & 16.9 MHz & 10\%      & 15.8 MHz & 16.9 MHz & 7.5\% \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Usable clock frequency range with Software-UART}
  \label{tab:SWfixErrs}
\end{table}

All measurement series with the software UART solution show a larger frequency range without errors compared to hardware UART operation from the table \ref{tab:HWfixErrs}.
This is probably due to the fact that the software solution only scans the input signal per bit once and tries to place
this reading in the middle of the transmission time expected with the baud rate.
The hardware UART solution of the AVR processors use 3 samples per data bit.
In the "Double Speed Mode" used here, scan numbers 4, 5 and 6 of the 8 scans are used for each data bit or stop bit.
The three scans before (1-3) and the two after (7-8) are not used.
At least 2 samples of the 3 used readings must result in a 1 for the stop bit sampling, otherwise a "framing" error is generated.
This oversampling process copes better with disturbed transmission, but allows less tolerance in the baud rate.\\

I have not found any more detailed information about the type of scanning of the serial data of any USB-serial converter.
But I assume that they all use a form of oversampling similar to the AVR-UART interface.
However, the scanning method of the individual USB-serial converters must differ.
There is no other way to explain the different test results because the optiboot side was the same for all test candidates.

\subsection{Extreme test with 115200 Baud at 8 MHz clock}

The wide baud rate range for a functioning serial communication of some USB-serial converters has encouraged me
to investigate the behavior of the autobaud function in practice for a baud rate of 115200 baud at a clock rate of 8 MHz.
For this I have chosen the USB-serial converter with the greatest baud rate tolerance, the CP2104.
I provided the ATmega1281 used for the tests with an optiboot bootloader with Autobaud mode 32 without the LED flashing.
In the Autobaud group 30-39, 4 data bits are used to measure the baud rate.
With this setting 40 downloads of 10 kByte with avdrude for 41 frequencies from 7 MHz to 9 MHz in 50 kHz steps were done.
To evaluate the result, the same series of measurements was repeated with a fixed baud rate of optiboot.
The baud setting to 111111 generates an UBRR setting of the hardware UART to 8,
with the selection 125 kBaud a UBRR setting of 7 is used.
Of course the actual baud rate changes proportionally with the frequency change.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c  r || c | c | c | c | c | c |}
    \hline
    & Type     & \multicolumn{5}{c |}{CP2104}          & CH340G \\
    & Mode   &  HW32 & HW111111 & HW125000 & SW32 & SW34 & HW32 \\
Frequency  & Period & auto & UBRR=8 & UBRR=7 & auto & auto & auto \\
    \hline
7000000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
7050000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
7100000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7150000  &    &  0    &  40      &   0      &  4   &  0   &  0 \\
    \hline
7200000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7250000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7300000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7350000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
    \hline
7400000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7450000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7500000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
7550000  &    &  0    &  40      &   0      &  0   &  0   &  0 \\
    \hline
7600000  &    &  0    &  40      &   0      &  0   &  7   &  40 \\
7650000  &    &  0    &  40      &   0      &  0   &  40  &  40 \\
7700000  &    &  0    &  40      &   0      &  0   &  40  &  40 \\
7750000  &    &  0    &  40      &   0      &  0   &  0   &  40 \\
    \hline
7800000  &    &  16   &  40      &   0      &  0   &  0   &  40 \\
7850000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
7900000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
7950000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
    \hline
8000000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8050000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8100000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8150000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
    \hline
8200000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8250000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8300000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8350000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
    \hline
8400000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8450000  &    &  0    &  0       &   40     &  0   &  0   &  0 \\
8500000  &    &  0    &  0       &   40     &  0   &  24  &  0 \\
8550000  &    &  0    &  0       &   40     &  0   &  40  &  40 \\
    \hline
8600000  &    &  0    &  0       &   40     &  0   &  0   &  40 \\
8650000  &    &  0    &  0       &   40     &  0   &  0   &  40 \\
8700000  &    &  0    &  0       &   40     &  0   &  0   &  40 \\
8750000  &    &  15   &  0       &   40     &  0   &  0   &  40 \\
    \hline
8800000  &    &  40   &  40      &   40     &  0   &  0   &  40 \\
8850000  &    &  0    &  40      &   40     &  0   &  0   &  0 \\
8900000  &    &  0    &  40      &   40     &  0   &  0   &  0 \\
8950000  &    &  0    &  40      &   40     &  0   &  0   &  0 \\
9000000  &    &  0    &  40      &   40     &  0   &  0   &  0 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Error rate of the extreme tests with 115200 Baud and 8 MHz clock}
  \label{tab:ExtremErrs}
\end{table}

All test results in the table \ref{tab:ExtremErrs} represent the number of failed attempts at the
respective clock rate (column 1) of 40 download attempts of 10 kByte with avrdude.
The USB-serial converters always use 2 stop bits for these tests.
The unsuccessful attempts for a CP2104 USB-serial converter are recorded in the first data column.
The PL2303TA chip has shown the same result for this test.
As you can see there are three total failures between 7850 kHz and 7950 kHz,
none of the 40 downloads worked.
The explanation is provided in the next two columns.
The 40 downloads were attempted for the entire frequency range with the constant UART
divider setting 9 (UBRR = 8) and 8 (UBRR = 7).
Neither of the two settings works for the frequencies 7850 kHz to 7950 kHz.
However, no further setting can be selected between UBRR=7 and UBRR=8.
It is therefore clear why no Autobaud variant can work here.
With these preconditions it is simply not possible to set the desired baud rate of 115200
with these clock frequencies with sufficient accuracy.
The partial failure of the download at 7800 kHZ with the Autobaud variant 32
is probably due to the uncertainty of the baud rate measurement.\\

In the fourth data column, the download was attempted with the same settings with the software UART solution from optiboot.
The table \ref{tab:SWfixErrs} on page \pageref{tab:SWfixErrs} with the software UART showed a larger 
Frequency working range compared to the CP2104 hardware UART tests in table \ref{tab:HWfixErrs} on page \pageref{tab:HWfixErrs}.
In addition, the delay time of the software UART is formed with waiting loops that allow a setting of multiples of 6 tics.
Due to the pre-divider of the hardware UART, the UBRR setting results to delay times with multiples of 8 clock tics.
Both circumstances lead to the fact that with the CP2104 the software solution shows only 4 unsuccessful download attempts
in the entire frequency range at the clock frequency 7150 kHz, a really amazing result!
Above a clock rate of 7200 kHz, the baud rate 115200 can be used without restriction with this CP2104 USB-serial converter,
when the 2 stop bit operation and software UART of the optiboot with BAUD\_RATE=32 is used.\\

As a further test with the software UART solution from optiboot, I tested the BAUD\_RATE=34 setting.
With this setting, the delay loop is lengthened by one clock, so that only a multiple of 8 clocks can be selected here,
just like the hardware UART can do.
This option only exist, because it result to a slightly shorter optiboot program.
Although this software UART setting has exactly the same multiple of 8 clocks for the period as the hardware UART,
the result is slightly better here.
This is probably due to the already mentioned larger frequency working range of the CP2104 converter
with optiboot in software UART operation.
In addition, the critical area here is not as close to the selected working frequency of 8 MHz as with the hardware UART.\\

In the 6th and last data column I tested the same measurement as in the first data column with the CH340G converter.
You see significantly more frequencies with total failures of the download attempts here,
what the investigation in table \ref{tab:HWfixErrs} on page \pageref{tab:HWfixErrs} expected.

\subsection{Extreme test with 230400 Baud at 16 MHz clock rate}

After the preliminary investigations at 8 MHz clock and 115200 baud, I also examined all
available USB-serial converters with 230400 baud and an autobaud setting 32 of the AVR.
The baud rate is calculated from the transmission time for 4 data bits.
A counter with / 8 prescaler is used to measure the time.
The clock of the AVR was starting in steps of 100 kHz
at 14 MHz increased to 18 MHz.
40 downloads of 10 kByte each with the modified avrdude (2 stop bits) are tried for each frequency.
The table \ref{tab:ExtremErrs16} shows the results for the existing USB-serial converters.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
\multicolumn{1}{| r |}{Typ}  & FT232   &  FT232 & CH340G & CP2102 & CP2104 & PL2303 & Pololu & Arduino \\
Frequenz       &  RL     &  clone &        &        &        & TA     & AVR    &  UNO \\
    \hline
14000000       &  40     &  40    &  40    & 40     & 40     & 40     & 40     & 0 \\
14100000       &  40     &  40    &  40    & 40     & 40     & 40     & 40     & 0 \\
14200000       &  4      &  40    &  0     & 0      & 0      & 0      & 40     & 0 \\
14300000       &  0      &  0     &  0     & 0      & 0      & 0      & 40     & 0 \\
14400000       &  0      &  0     &  0     & 0      & 0      & 0      & 40     & 0 \\
14500000       &  0      &  0     &  1     & 0      & 0      & 0      & 0      & 0 \\
14600000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
14700000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
14800000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
14900000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
%              & FT232   &  FT232 & CH340G & CP2102 & CP2104 & PL2303 & Pololu & Arduino \\
    \hline
15000000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
15100000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
15200000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 40 \\
15300000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 40 \\
15400000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 0 \\
15500000       &  0      &  0     &  40    & 40     & 0      & 0      & 0      & 0 \\
15600000       &  35     &  23    &  40    & 40     & 19     & 15     & 40     & 0 \\
15700000       &  40     &  40    &  40    & 40     & 40     & 40     & 40     & 0 \\
15800000       &  40     &  40    &  40    & 40     & 40     & 40     & 40     & 0 \\
15900000       &  40     &  40    &  40    & 0      & 40     & 40     & 40     & 0 \\
    \hline
16000000       &  0      &  29    &  0     & 0      & 0      & 0      & 40     & 0 \\
16100000       &  0      &  0     &  0     & 0      & 1      & 0      & 40     & 0 \\
16200000       &  0      &  0     &  0     & 0      & 0      & 0      & 40     & 0 \\
16300000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
16400000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
16500000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
16600000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 0 \\
16700000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
16800000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
16900000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
    \hline
17000000       &  0      &  0     &  0     & 0      & 0      & 0      & 0      & 40 \\
17100000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 0 \\
17200000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 0 \\
17300000       &  0      &  0     &  40    & 0      & 0      & 0      & 0      & 0 \\
17400000       &  0      &  0     &  40    & 8      & 0      & 0      & 0      & 0 \\
17500000       &  18     &  4     &  40    & 40     & 18     & 20     & 17     & 0 \\
17600000       &  40     &  40    &  40    & 40     & 40     & 40     & 40     & 0 \\
17700000       &  40     &  40    &  0     & 0      & 0      & 0      & 40     & 0 \\
17800000       &  0      &  6     &  0     & 0      & 0      & 0      & 40     & 0 \\
17900000       &  0      &  0     &  0     & 0      & 0      & 0      & 40     & 0 \\
18000000       &  0      &  0     &  0     & 0      & 0      & 0      & 40     & 0 \\
    \hline
\multicolumn{1}{|r|}{Total:} &  337    &  382   &  641   & 328    & 278    & 275    & 697    & 360 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Error rate of the extreme test with 230400 Baud at 16 MHz Clock}
  \label{tab:ExtremErrs16}
\end{table}

Again the CP2104 and the PL2303 show the fewest failures in the table \ ref {tab: ExtremErrs16}
over the entire frequency range.
The serial output of the USB-serial converter was operated with two stop bits in this investigation
and the optiboot bootloader worked with the hardware UART.
If the software UART from optiboot had been used, the result would have been even better.
Unfortunately, apart from the Arduino UNO with the ATmega16U2 as a USB-serial converter,
all other USB-serial converters show failures just below the clock rate 16 MHz.
The FT232clone itself has problems with the download even at 16 MHz, with the Pololu
an entire frequency range around 16 MHz cannot be used.
Almost all USB-serial converters try to adhere to the baud rate of 230400 as precisely as possible,
which works quite well because of the higher internal clock rate of around 48 MHz to 96 MHz.
In contrast, the ATmega16U2 uses a baud rate of 222222, the same as generated by the ATmega1281
used for the tests at 16 MHz.
This is the reason why the Mega16U2 installed on the Arduino UNO shows no problems with the download
to the ATmega1281 in the clock frequency range around 16 MHz. \\

If the existing USB-serial converter supports operation with 250000 baud,
this setting is probably more favorable with an AVR clock rate of 16 MHz,
since this baud rate can be generated without any deviation.
With an optiboot with the autobaud function, you can simply try out if the higher baud rate is possible.


\subsection{Summary and recommendations}
\begin{itemize}

\item{USB-Serial converters} \\
The USB-serial converter FT232RL, CP2102, CP2104 and also the ATMega16U2 used by an Arduino UNO board variant 
has shown good results with the tests.
For a new purchase, I would recommend the CP2104, which operates with the largest baud rate range
at the 115200 baud setting in the tests.
With the PL2303 module I had difficulties during the tests, the Linux driver reported errors and
the results of the tests were inconsistent.
I also had to retrofit a DTR output pin because this pin was missing on my module.
Only after I swapped the PL2303HX chip for a PL2303TA did the results improve.
The GND (Pin 7) of the PL2303TA chip also had to be rewired on the board.
After refitting the PL2303 modul I get the same good results as CP2104 did with the PL2303TA.
Actually I noticed some Chinese offers of a Arduino Nano clone build with the PL2303TA chip instead of the usual CH340G.

\item{2 stop bits} \\
The extensive tests, which are summarized in the tables \ref{tab:HWfixErrs} on page \pageref{tab:HWfixErrs} and 
\ref{tab:SWfixErrs} on page \pageref{tab:SWfixErrs}, showed that the use of a second stop bit for the transmit data 
increases the usable baud rate difference significantly.
This shows that the occurrence of unfavorable baud rate combinations with 2 stop bits is reduced.
Unfortunately the standard avrdude with version 6.3 does not allow the use of a second stop bit.
You can try to patch the avrdude version 6.3 sources with the diff documentation in the
file ee\_test/avrdude.diff.
The loss of speed is insignificant, you gain more speed, if you can select a higher baud rate instead.

\item{Selection of a automatic baud mode} \\
With the last improvement of the autobaud function, the simplest measurement of the baud rate
with the setting BAUD\_RATE=22 can also be used with good results.
This is interesting because this version uses the least amount of memory.
Unfortunately, one more assembler command is required for this useful improvement (prescaler reset),
so that 2 bytes of flash are more used for all autobaud modes with clock prescaler
for the counter (One-digit of the baud rate \textless 5).
The memory consumption is nevertheless lower compared to using the counter at full clock rate
(One-digit of the baud rate \textgreater 4).
\textbf {I recommend measuring the baud rate over 4 data bits (mode 32).} The additional control
function of mode 52 can be omitted.
The use of full control of the data byte with baud rate \textgreater 59 is not recommended,
especially when using the counter with prescaler, the baud rate measurements are significantly worse.
The measurement of the baud rate over 9 bits (BAUD\_RATE=12) can be used without restrictions,
but the measurement over 4 bits is completely sufficient and requires less memory.

\item{Usage of software UART} \\
There are several reasons that make the use of the software UART solution necessary,
such as using other pins for serial communication or one-pin communication (same selection for RX and TX pin).
The autobaud function can also be used in this case.
Because both the software UART solution and the autobaud function require more flash memory,
it is becoming more and more difficult to fit the optiboot in 512 bytes flash.
Of course you don't have to worry about the 512 byte limit,
if the target processor has a larger bootloader page such as 1024 bytes.
You should try the configurations of optiboot to fit in 512 byte flash with make calls without the ISP option or with
the ISP option set to 0.
You can try out the different options until you find a suitable configuration that fits in 512 bytes.
By the way, the size of the bootloader page of the target processor is displayed in the terminal log 
with every make call that specifies a target processor.\\

First you should switch off the blinking function of the LED with LED\_START\_FLASHES=0 in order to save space.
If you absolutely need something to light up, you can use the LED\_DATA\_FLASH=4 function,
because it only needs 4 bytes of flash instead of the 56 bytes of the flashing function.
The table \ref{tab:AutoBaudLen328} on page \pageref{tab:AutoBaudLen328} gives advance information
about the memory required for all setting options.\\
With the option NO\_EARLY\_PAGE\_ERASE=1 additional 14 bytes can be saved,
whereby this only makes the loading of the user program a little slower.\\
You should leave the possibility of writing data to the EEprom enabled, if possible.
Switching off the function is also possible with SUPPORT\_EEPROM=0, but saves only about 24 bytes.\\

If more interference is to be expected in the transmission, for example because longer cables are used,
the hardware UART should be used if possible and higher baud rates should be avoided.
	

\end{itemize}

\section{Final remark}

When I started working on converting optiboot to assembler and installing EEprom support,
I had no idea how much could be examined and expanded here.
The first task was to build an optiboot that supports loading EEprom data and fit to 512 bytes of flash.
That seemed a manageable effort to me.\\

But there was also the support of many AVR processors to be built in,
which  had to be purchased first.
The different bootloader page sizes and flash page sizes had to be taken into account.
Of course everything also had to be tested too.
Many processors with many options results to many program variants with different program lengths,
which are now always automatically taken into account.
This avoids incorrect setting of the AVR fuses for all supported processors.\\
The software UART solution has been optimized so that it works well and can now also operate with one IO pin.
The automatic baud rate adjustment (autobaud) was installed and tested.
Many autobaud variants can now be selected, whereby the autobaud function works with both,
the hardware UART and the software UART solution of optiboot.\\


The possibility of adjusting the internal RC oscillator as a clock for the supported AVRs was examined
and the setting option OSCCAL\_CORR was integrated in optiboot.\\

The 512 byte limit for the flash is a particular challenge when combining autobaud and software UART,
even if you deselect the LED flashing function.
Of course, optiboot also runs if more than 512 bytes are required.
The limit was only my goal, I wanted to integrate most functions into the 512 bytes.
With the option NO\_EARLY\_PAGE\_ERASE a way was found to save a few bytes if necessary.
This makes the flash writing a little slower, but if, for example,
a higher baud rate can be selected in the autobaud mode, this is more than compensated.
The advantage of the autobaud function is that you can try out the higher baud rate such as 115200 baud at 8 MHz.
If that doesn't work, you can switch to a lower baud rate without changing the bootloader.\\

So I was able to prove in extensive test series that a larger deviation of the baud rate is tolerated
from avrdude with the use of a second stop bit for the transmitted serial data.
It is a little surprising that this has not been noticed so far.
Otherwise the second stop bit should at least be selectable as an option from avrdude.\\

Even when I thought there was nothing more to improve, I got the idea to reset the frequency prescaler
for counters during the final tests of the autobaud function with various USB-to-serial converters.
This is rarely used because the prescaler is shared by all integrated counters.
But here in optiboot this function can be used and leads to a reduction in autobaud time measure errors
if the counter is used with /8 prescaler.\\

I am sorry that the many setting options for optiboot are confusing for a user.
As far as possible, I have taken over the options of the C version from Peter Knight ands
Bill Westfield to make it easier for users of the original version of optiboot.
Otherwise I hope that the examples from chapter \ref{Examples} on page \pageref{Examples} facilitate the first introduction.
In addition, a make call with the desired target processor as a parameter is sufficient
to generate an executable optiboot as a .hex file.
The terminal log shows which setting has been selected.
That is always a matching clock frequency and a (fixed) baud rate preselected for this specific processor.\\
If necessary, the presettings can of course be changed with options.

