\chapter{Build of optiboot Bootloaders}

\section*{}
Creating optiboot requires a Linux system with the following packages installed:
\begin{itemize}
	\item{avr-gcc}
	\item{binutils-avr}
	\item{avrdude}
	\item{bash}
	\item{bash-completion}
	\item{bc}
	\item{grep}
\end{itemize}
Some of the packages may already be installed by default.
You should work in the bash command line.
This can be either a terminal window or a virtual console.
Normally, Linux allows you to switch between 6 virtual consoles using the key combinations \textbf{<Ctrl>+<Alt>+<F1>} to \textbf{<Ctrl>+<Alt>+<F6>}.
In the consoles, you must log in first with your username and password.
However, you can also work in a terminal window in the graphical interface using \textbf{(<Ctrl>+<Alt>+<F7>)}.
If you want to repeat a command line with minor changes, you can press the \textbf{Up Arrow} key $\uparrow$ on your keyboard to recall an old command.
If you only want to add a parameter, you can simply type it in and press the \textbf{Return} key.

You can also use the \textbf{left arrow} $\leftarrow$ key to move the cursor to the point in the old command you want to change.
These few introductory sentences are intended to make it easier for Linux newcomers to get started,
but the following instructions are for everyone.
Creating the optiboot bootloader should be done in two main steps.
First, the program should be created on the PC without writing it to the target processor (Atmel microcontroller).
Only in the second main step should you attempt to load the program onto the target processor.
This division is due to the fact that many settings are checked beforehand and the creation process can be aborted with an error message.
You should also check the screen log to determine whether the entered parameters have been processed correctly, i.e., entered without typos.
For each of the supported processors, there are default settings, which can be changed by
entering parameters when calling \textbf{make}.
The capabilities of the optiboot bootloader are described in the chapter \ref{sec:optiboot} starting on page \pageref{sec:optiboot}.
The most important capabilities are listed on page \pageref{item:capability}.
The available parameters are listed in table \ref{tab:options1} on page \pageref{tab:options1}
and in table \ref{tab:options2} on page \pageref{tab:options2}, as well as in table \ref{tab:options3} on page \pageref{tab:options3}.
If certain parameters should not change during the test runs,
they can also be defined as environment variables.
A good example of this is the ISP programmer type used.
The corresponding variable is called ISPTOOL.
If this variable is not specified as an environment variable or as a parameter in the \textbf{make} call,
\textbf{avrisp2} is assumed to be the type.
If the type is not correct for you, you can change it in the \textbf{make} call as follows:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328p ISP=1 ISPTOOL=stk500
\end{Verbatim}
Alternatively, you can also set ISPTOOL as an environment variable and call \textbf{make} without this parameter, like this:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
export ISPTOOL=stk500
make atmega328p ISP=1
\end{Verbatim}
Until the end of your terminal session, you no longer need to specify the ISPTOOL parameter in any subsequent \textbf{make} commands.
The ISP programmer type in this terminal will then be set to stk500.
If you are unsure whether and which programmer type is set after a long break, the 
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
printenv ISPTOOL
\end{Verbatim}
command will provide this information.
If the default setting for ISPTOOL on stk500 is to apply to all terminal windows in the future,
the \textbf{export ISPTOOL=stk500} can be appended to the hidden text file \raisebox{-0.3ex}{\textasciitilde}/.bashrc .
Especially when intending to flash different AVR microcontrollers with a new bootloader,
processor-type-dependent parameters should \textbf{not} be hard-coded using environment variables.


\section{A simple example of creating an optiboot}

To avoid many pitfalls in generating a working bootloader,
the bootloader file generation process has been largely automated.
In addition, settings are checked, and the generation process is aborted with
an appropriate error message if, for example, the selected operating frequency (AVR\_FREQ)
does not match the clock settings configured with the fuses (CKSEL, CKDIV8).
A target processor for the optiboot bootloader must be specified as the first parameter in the \textbf{make} command.
If possible, you should also run the examples on your own PC.
If you are working in a terminal window, use the \textbf{cd} command to navigate to your optiboot directory and then type in the \textbf{make} commands.
If you're too lazy to type, you can also open the PDF documentation and select the entire \textbf{make} commands
with the left mouse button and copy them into the terminal window using the middle mouse button.
To select the command, hold down the left mouse button and drag it over the entire command, or
you can probably also hover the mouse pointer over the line and click the left mouse button three times.
Let's start with a simple example:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328
\end{Verbatim}
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret 
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2 -DLED=pB5 -DUART=00
 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF
 -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    490	      0	      0	    490	    1ea	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 
\end{Verbatim}
Looking at the screen log, the first lines show which microcontroller the bootloader is configured for,
along with its clock rate and serial interface baud rate.
The following lines specify the pins used and what special functions these pins can have on this microcontroller.
This information is particularly useful when using a non-standard configuration.
This can, for example, prevent an unfavorable assignment of the LED function.
Following the compiler call, the target and real baud rates are displayed, along with a percentage error.
The bootloader's starting address, the number of boot memory pages used, and the bootloader's size are also shown.
Despite the simple call, this configuration would work for common boards like the \textbf{Arduino UNO} or \textbf{Arduino Nano}.
The number of boot memory pages, which depends on the size of the bootloader, is automatically taken into account when programming the ATmega328.
This ensures a working bootloader even with significantly larger versions.
Out of pure curiosity, we could test what the result would be if we used the C source code instead of the assembly version:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 C_SOURCE=1
\end{Verbatim}
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=0 -DNO_APP_SPM=2 -DLED=pB5
 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE
 -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.c
optiboot.c: In function ‘t1_delay’:
optiboot.c:1538:1: warning: control reaches end of non-void function [-Wreturn-type]
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    504	      0	      0	    504	    1f8	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 
\end{Verbatim}
That's a surprise, the program matches the same bootloader memory as the assembler version.
Let's double-check if something went wrong.
The \textbf{avr-gcc} call specifies the program optiboot.c and not optiboot.S at the end.
So the parameter \inquotes{C\_SOURCE=1} is being processed correctly.
However, if you look more closely, the first line of the screen log is missings
the note \inquotes{and EEPROM support}.
That's right, in the parameter list for the \textbf{avr-gcc} call,
EEPROM support is indeed disabled with \inquotes{-DSUPPORT\_EEPROM=0}.
However, EEPROM support can certainly be re-enabled:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 C_SOURCE=1 SUPPORT_EEPROM=1
\end{Verbatim}
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2 -DLED=pB5 -DUART=00
 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF
 -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.c
optiboot.c: In function ‘t1_delay’:
optiboot.c:1542:1: warning: control reaches end of non-void function [-Wreturn-type]
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7C00 = 31744
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    602	      0	      0	    602	    25a	optiboot.elf
Requires 2 Boot Pages, 512 Bytes each, which is 3.1% of Flash Memory
BOOTSZ=2, which means 2 Boot Pages

\end{Verbatim}
Now the result looks quite different.
The program with the same capabilities as the assembler version is 114 bytes larger and now uses twice as much space in 
the ATmega328's flash memory with two boot memory pages.
So that was the reason for switching from the C programming language to assembler.
It was worth fighting for every byte!
If one were to attempt to load this bootloader onto the ATmega328 using the additional parameter
\inquotes{ISP=1}, this bootloader would be executable,
since the ATmega's fuses and the start address would be automatically adjusted to the larger bootloader version.
It is now also understandable why EEPROM support is omitted in the standard configuration for the C source.
The bootloader is designed to fit into a 512-byte boot page by default.


\section{Exotic examples for Optiboot creation}
If we now repeat the standard call with a different target processor, the result looks completely
different:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make attiny88
\end{Verbatim}
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 8000000 Hz (8.00 Mhz) operation with Baudrate 115200 and EEprom support configured.
 >>> Start building optiboot for AVR attiny88:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 .
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 .
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=attiny88  -fno-diagnostics-show-caret
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2
 -DVIRTUAL_BOOT_PARTITION=1  -DLED=pB5 -DUART=00 -DSOFT_UART=01 -DUART_RX=pD0
 -DUART_TX=pD1 -DF_CPU=8000000 -DHFUSE=hexDD -DLFUSE=hexEE -DBOOT_PAGE_LEN=64
 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  SoftUART_Real: 115942, Delay: 46*1, Difference=.64%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x1D80 = 7552
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    588	      0	      0	    588	    24c	optiboot.elf
Requires 10 Flash Pages, 64 Bytes each, which is 7.8% of Flash Memory 
No Boot Pages present!
 
\end{Verbatim}
Initially, the operating frequency is now 8 MHz, and a software emulation of the serial interface is used
on pins PD0 and PD1 for the bootloader.
The absence of a serial interface can be seen in the options list for the compiler \textbf{avr-gcc}
from the automatically set option \inquotes{-DSOFT\_UART=1} and in \inquotes{BAUD RATE CHECK:} from the word \textbf{SoftUART\_Real}.
The stated difference to the desired baud rate of 115000 should not be misleading.
If the ATtiny88 is operated with its internal clock generator, it probably does not maintain the clock frequency exactly,
and therefore the calculated baud rate will actually deviate from the real value.
Furthermore, the ATtiny88 does not support a bootloader function.
Instead, a software-based emulation is used.
However, the bootloader is loaded into the upper memory area, just like a real bootloader function (Bootloader start address:).
Therefore, the bootloader program is significantly larger and uses 10 flash memory pages of 64 bytes each.
Now, another example with a different microcontroller:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make attiny87
\end{Verbatim}
Here too, the protocol on the screen looks different:
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 8000000 Hz (8.00 Mhz) operation with Baudrate 115200 and EEprom support configured.
 >>> Start building optiboot for AVR attiny87:
LED-Pin PA2 use Pin  3-SOIC20 31-MLF32, with special functions: MISO D0 OC0A ADC2 PCINT2.
 RX-Pin PA0 use Pin  1-SOIC20 29-MLF32, with special functions: RXLIN RXD ADC0 PCINT0.
 TX-Pin PA1 use Pin  2-SOIC20 30-MLF32, with special functions: TXLIN TXD ADC1 PCINT1.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=attiny87  -fno-diagnostics-show-caret
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2
 -DVIRTUAL_BOOT_PARTITION=1  -DLED=pA2 -DUART=00 -DSOFT_UART=0 -DUART_RX=pA0 -DUART_TX=pA1
 -DF_CPU=8000000 -DHFUSE=hexDD -DLFUSE=hexE2 -DBOOT_PAGE_LEN=128
 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 111111, UBRR = 8, Difference=-3.54%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x1D80 = 7552
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    572	      0	      0	    572	    23c	optiboot.elf
Requires 5 Flash Pages, 128 Bytes each, which is 7.8% of Flash Memory 
No Boot Pages present!
 
\end{Verbatim}
This microcontroller also lacks bootloader support but has a serial interface,
which is supported by the bootloader by default.
The bootloader program occupies 5 flash memory pages of 128 bytes each.
These examples are intended to show what information about the target processor is available when calling \textbf{make}.
If you want to change the default bootloader settings by entering parameters, you should
always carefully read the screen log to ensure that the result is as desired.

\section{Example of Optiboot creation with special function}
But now back to the widely used ATmega328 microcontroller.
Now we want to try using an automatically determined baud rate instead of a fixed one.
This is selected by specifying a baud rate below 100. Here, the specified number selects different
methods, which are described in the subsection \ref{sec:autobaud} on page \pageref{sec:autobaud}.
Based on our investigations, specifying 32 is a good choice:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 BAUD_RATE=32
\end{Verbatim}
The screen log now looks like this:
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret
 -DBAUD_RATE=32 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2 -DLED=pB5
 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE
 -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
Simple Baudrate measurement implemented in optiboot! (4-bit, Clk/8)
UART Minimum 488 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7C00 = 31744
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    554	      0	      0	    554	    22a	optiboot.elf
Requires 2 Boot Pages, 512 Bytes each, which is 3.1% of Flash Memory
BOOTSZ=2, which means 2 Boot Pages

\end{Verbatim}
It's noticeable that the bootloader now requires 552 bytes, slightly more than a single boot page (512 bytes).
However, this means two boot pages are being used, requiring 1024 bytes.
This configuration could be loaded into the microcontroller.
All the fuses would be set correctly.
But it's a waste of flash memory space.
Perhaps disabling unnecessary functions would help.
Let's try it with the LED that the bootloader blinks three times at startup.
The bootloader should also run without the blinking LED, so:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 BAUD_RATE=32 LED_START_FLASHES=0
\end{Verbatim}
The screen log now looks much better:
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret
 -DBAUD_RATE=32 -DLED_START_FLASHES=0 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2 -DLED=p
 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE
 -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
Simple Baudrate measurement implemented in optiboot! (4-bit, Clk/8)
UART Minimum 488 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    496	      0	      0	    496	    1f0	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 
\end{Verbatim}
The bootloader is back to using a single boot page.
However, it no longer uses an LED to indicate that the bootloader is starting.
But there's still the option \textbf{LED\_DATA\_FLASH}.
This option normally turns on the LED when the serial interface is waiting for data.
With the special setting 4, the LED is only turned on when the bootloader starts.
That should be enough to detect that the bootloader has started and certainly doesn't require much program space, so:

\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 BAUD_RATE=32 LED_START_FLASHES=0 LED_DATA_FLASH=4
\end{Verbatim}
The LED port is now being used again, as the log shows:
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-caret
 -DBAUD_RATE=32 -DLED_START_FLASHES=0 -DLED_DATA_FLASH=4 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2s
 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE
 -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
Simple Baudrate measurement implemented in optiboot! (4-bit, Clk/8)
UART Minimum 488 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    500	      0	      0	    500	    1f4	optiboot_atmega328.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 

\end{Verbatim}
This would be an alternative to the standard bootloader with a fixed baud rate.
With this bootloader, you can first test the standard baud rate of 115200.
If there are any problems, you can upload a program with a lower baud rate, such as 57600,
without having to reprogram the bootloader beforehand.
Changing the clock rate with a different crystal also causes fewer problems this way.

\section{Load Optiboot into the target processor}

\subsection{Requirements for uploading to the AVR}
Once a suitable bootloader for a microcontroller has been created, the next step is to upload the bootloader to the microcontroller.
The microcontroller board should have an ISP interface.
Ideally, this is a 6-pin or 10-pin male header, as shown in Figure \ref{fig:ISP} on page \pageref{fig:ISP}.
We also need an ISP programmer, which ideally should have the same male header.
A ribbon cable with matching female connectors is also required.
The ribbon cable is often included with the ISP programmer.
Most commercially available ISP programmers use a USB interface to connect to the PC.
The USB interface offers the advantage over a serial interface that it
can supply power (5V or 3.3V) to both the programmer and the microcontroller board.
This means no additional power supply is needed during programming.
You only need to connect the target board and the ISP programmer with the ribbon cable, and then connect the
ISP programmer to a free USB port on your PC.
The order of connection is arbitrary.
Special care is required when programming the Atmel processor on a separate socket.

All Atmel processors I am aware of run with an internal clock in their factory state, which is often divedes by 8.
If the processor is to run on the board with a crystal oscillator, the first programming step is to program the fuses.
Because it must be assumed that the clock speed during this step is significantly lower than
specified in the \textbf{make} call for the bootloader, this step is generally performed at a slow bit rate (\textbf{avrdude -B 500}).
This step therefore runs with every new Atmel processor.
However, if the Atmel processor is already set to crystal operation, the first programming step will not run,
as the processor lacks any clock signal without the crystal.
For the same reason, the subsequent programming steps for the Atmel processor cannot run without the crystal.
This problem is solved by adding a crystal to the programming socket.
Except for the first programming step (setting the fuses), the bit rate (\textbf{avrdude -B})
is automatically adjusted to the selected clock rate (AVR\_FREQ) of the Atmel processor during programming.

\subsection{Programming with ISP default settings}

After plugging the ISP programmer into a USB port, a newly inserted USB device should generate an entry in the system log on a Linux system.
You can check this with the following command:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
dmesg -T | tail -20
\end{Verbatim}
\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
...
usb 1-3: new full-speed USB device number 19 using xhci_hcd
usb 1-3: New USB device found, idVendor=03eb, idProduct=2104, bcdDevice= 2.00
usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 1-3: Product: ERFOS AVRISP MkII Clone
usb 1-3: Manufacturer: ERFOS
usb 1-3: SerialNumber: 0000A00128255
\end{Verbatim}
This example protocol comes from an older Diamex AVR-Prog programmer and
was generated with \textbf{dmesg -t} (without a time). However, you should use the \textbf{-T} option
to be able to check the entry time.
This programmer is compatible with the Atmel AVRISP mkII and is pre-configured
as the programmer (ISPPORT=usb, ISPTOOL=avrisp2).
For this programmer, only the parameter \textbf{ISP=1} needs to be appended to the \textbf{make} call.
So, for the last example with automatic baud rate detection:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328 BAUD_RATE=32 LED_START_FLASHES=0 LED_DATA_FLASH=4 ISP=1
\end{Verbatim}

\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom support configured.
 >>> Start building optiboot for AVR atmega328:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328  -fno-diagnostics-show-carets
 -DBAUD_RATE=32 -DLED_START_FLASHES=0 -DLED_DATA_FLASH=4 -DSUPPORT_EEPROM=1
 -DNO_APP_SPM=2 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
Simple Baudrate measurement implemented in optiboot! (4-bit, Clk/8)
UART Minimum 488 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text	   data	    bss	    dec	    hex	filename
    500	      0	      0	    500	    1f4	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page

####### Start of program_target.sh for atmega328 #############
   The fuses in program_target.sh are set to lfuse=0xFF, hfuse=0xDE, efuse=0xFD
Bootloader HFUSE will be set to 0xDE, OK!
BootLoader Start is enabled to 0x7E00, 32256
##### erase the atmega328 and set fuses
avrdude  -c avrisp2 -B 500 -p atmega328 -P usb -b 115200 -q -q -e  -U efuse:w:0xFD:m
-U hfuse:w:0xDE:m -U lfuse:w:0xFF:m
Error: expected signature for ATmega328 is 1E 95 14
  - double check chip or use -F to carry on regardless
#-#-#-#-#-#-#-#
*** avrdude *** failed with return value 1!
#-#-#-#-#-#-#-#
If avrdude has not started with the Programmer communication,
this can be caused by a wrong ISPPORT [now: usb] setting!
Looking for serial Ports at your Linux system:


No device with name /dev/ttyUSBx or /dev/ttyACMx found! x can be any sequence number!

Check the connection of your  ISP programmer to a USB interface of your PC.
If you are in doubt about the plugged in programmer, the command 'lsusb' may help,
The command 'lsusb' show all USB devices of your system.

You can learn more about the details of the just plugged programmer with
a command like 'dmesg | tail -20' , 'dmesg' shows the total log file of your Linux system
and '| tail -20' will display only the last 20 lines.

If the avrdude has started the communication to your target with the ISP-programmer,
your ISPPORT setting should be OK. So you have to check the cable connection
between the ISP-Programmer and your AVR target.
You should avoid the using of USB-Hubs with your ISP-Programmer!
USB-Hubs can cause timing problems with the half duplex protocol of avrdude.


Setting of fuses for atmega328 fail!
Check, if the atmega328 has a connected crystal!

\end{Verbatim}
Something went wrong! The program \textbf{avrdude} terminated with an error;
the reason can be seen in the \textbf{avrdude} error message:
\begin{Verbatim}[frame=single,rulecolor=\color{blue}]
avrdude error: expected signature for ATmega328 is 1E 95 14
        double check chip or use -F to override this check
\end{Verbatim}
The program \textbf{avrdude} expects a different microcontroller signature.
The following advice is irrelevant. The program \textbf{avrdude}
returns with a return value of 1 on every error, but the calling script
assumes a communication problem with the program \textbf{avrdude}.
However, the cause of the error is different: the Arduino Nano board uses an ATmega328P
not an ATmega328.
The two processors have different signatures.
\textbf{avrdude} has detected this, so communication between avrdude and the ATmega328P is working!
This is easily corrected:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328p BAUD_RATE=32 LED_START_FLASHES=0 LED_DATA_FLASH=4 ISP=1
\end{Verbatim}

\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
 
Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom support configured.
 >>> Start building optiboot for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p  -fno-diagnostics-show-caret
 -DBAUD_RATE=32 -DLED_START_FLASHES=0 -DLED_DATA_FLASH=4 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2
 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000 -DHFUSE=hexDE
 -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
Simple Baudrate measurement implemented in optiboot! (4-bit, Clk/8)
UART Minimum 488 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    500	      0	      0	    500	    1f4	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 
####### Start of program_target.sh for atmega328p #############
   The fuses in program_target.sh are set to lfuse=0xFF, hfuse=0xDE, efuse=0xFD
Bootloader HFUSE will be set to 0xDE, OK!
BootLoader Start is enabled to 0x7E00, 32256
##### erase the atmega328p and set fuses
avrdude  -c avrisp2 -B 500 -p atmega328p -P usb -b 115200 -q -q -e  -U efuse:w:0xFD:m
 -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m
##### write the optiboot bootloader to atmega328p and set the lock bits
avrdude  -c avrisp2 -B 1.50 -p atmega328p -P usb -b 115200 -D -U flash:w:optiboot_atmega328p.hex:i
 -U lock:w:0xef:m

Processing -U flash:w:optiboot_atmega328p.hex:i
Reading 500 bytes for flash from input file optiboot_atmega328p.hex
Writing 500 bytes to flash
Writing | ################################################## | 100% 0.07 s 
Reading | ################################################## | 100% 0.04 s 
500 bytes of flash verified

Processing -U lock:w:0xef:m
Reading 1 byte for lock from input file 0xef
Writing 1 byte (0xEF) to lock, 1 byte written, 1 verified

Avrdude done.  Thank you.

\end{Verbatim}
Everything worked well, the bootloader is installed on the Arduino Nano board.
The advantage of this type of ISP programmer is that it can be detected by the program \textbf{avrdude}
when the interface (-P) \inquotes{usb} is specified.
When you power on the target board with the newly installed bootloader,
the LED blinks slowly. This is because the bootloader starts first, waiting for serial data.
It turns the LED on. After the set timeout, it attempts to start the user program.
The LED then turns off again.
Since no user program is installed, the program counter continues to increment from 0
until the bootloader is reached again and the LED turns on.
As soon as a user program is loaded via the serial interface,
this effect disappears and the LED remains off after the timeout unless it is used differently by the user program.

\subsection{ISP programming with USB-to-serial interface}
Many other programmers don't use a direct USB interface.
Instead, they use a USB-to-serial converter, with the ISP programmer connected to the serial interface.
The operating system recognizes the USB-to-serial converter and assigns an entry
in the file system for accessing the serial interface.
On Linux systems, this is usually an entry in the form /dev/ttyACMx,
where x is a sequential number.
If the USB-to-serial converter consists of a special chip such as the FT232 or CH341,
a Linux system assigns an entry in the form /dev/ttyUSBx, where x represents a sequential number.
Since these special chips were relatively expensive, emulation using a microcontroller is often employed.
However, in both the form /dev/ttyACMx and /dev/ttyUSBx, the x in the name is determined
by the order in which the device is plugged into the PC's USB ports.
Once assigned, a name is retained until the device is unplugged.
If the first USB-to-serial converter is named /dev/ttyACM0,
the second USB-to-serial converter is named /dev/ttyACM1.
The second USB-to-serial converter retains this name even after the first USB-to-serial converter is unplugged.
However, newly plugged-in USB devices create an entry in the system ring buffer.
The contents of the system ring buffer can be displayed using the \textbf{dmesg} command.
Since the system ring buffer consists of many lines, you usually only need to look at the last few lines.
A suitable command for viewing the last 20 lines of the system ring buffer is:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
dmesg -t | tail -20
\end{Verbatim}
Here, \textbf{-t} was used instead of \textbf{-T} because the time is irrelevant in the printed example.
However, you should use \textbf{dmesg -T} to be able to check the entry time.
Shortly after plugging in a Diamex EXA-PROG programmer, you will see the following:
\begin{Verbatim}[frame=single,rulecolor=\color{blue}]
...
usb 1-3: new full-speed USB device number 24 using xhci_hcd
usb 1-3: New USB device found, idVendor=16c0, idProduct=2a9b, bcdDevice=45.80
usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 1-3: Product: EXA-PROG
usb 1-3: Manufacturer: ERFOS
usb 1-3: SerialNumber: 58491-80751-303
cdc_acm 1-3:1.0: ttyACM0: USB ACM device
\end{Verbatim}
If another USB-to-serial interface was previously plugged in,
the same programmer will register in the system ring buffer as follows:
\begin{Verbatim}[frame=single,rulecolor=\color{blue}]
...
usb 1-4: new full-speed USB device number 29 using xhci_hcd
usb 1-4: New USB device found, idVendor=16c0, idProduct=2a9b, bcdDevice=45.80
usb 1-4: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 1-4: Product: EXA-PROG
usb 1-4: Manufacturer: ERFOS
usb 1-4: SerialNumber: 58491-80751-303
cdc_acm 1-4:1.0: ttyACM1: USB ACM device
\end{Verbatim}
The last line shows that the name has changed from ttyACM0 to ttyACM1.
This provides this type of ISP programmer a way to correctly set the interface name
for \textbf{avrdude}.
The interface name is specified in the \textbf{avrdude} program using the parameter -P.
When calling \textbf{make}, the interface is specified using the parameter ISPPORT.
The protocol for the ISP programmer is specified with the parameter -c in the \textbf{avrdude} program,
in the \textbf{make} call, the corresponding parameter is ISPTOOL.
With the appropriate DIP switch settings, the Diamex EXA-PROG supports the STK500 protocol from Atmel.
The baud rate of the serial interface (Arduino parameter -b) is set to 115000 and
usually does not need to be changed with the ISPSPEED parameter.
Now, loading a standard optiboot bootloader works with the specification of two additional parameters:
\begin{Verbatim}[frame=single,rulecolor=\color{red}]
make atmega328p ISP=1 ISPPORT=/dev/ttyACM0 ISPTOOL=stk500
\end{Verbatim}

\begin{Verbatim}[frame=single,rulecolor=\color{blue},fontsize=\footnotesize]
Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom support configured.
 >>> Start building optiboot for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5.
 RX-Pin PD0 use Pin  2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD.
 TX-Pin PD1 use Pin  3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD.
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p  -fno-diagnostics-show-caret
 -DBAUD_RATE=115200 -DLED_START_FLASHES=3 -DSUPPORT_EEPROM=1 -DNO_APP_SPM=2 -DLED=pB5
 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 -DF_CPU=16000000
 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 -DVerboseLev=2 -c -o optiboot.o optiboot.S
 
--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #
 
   text	   data	    bss	    dec	    hex	filename
    488	      0	      0	    488	    1e8	optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Page
 
####### Start of program_target.sh for atmega328p #############
   The fuses in program_target.sh are set to lfuse=0xFF, hfuse=0xDE, efuse=0xFD
Bootloader HFUSE will be set to 0xDE, OK!
BootLoader Start is enabled to 0x7E00, 32256
##### erase the atmega328p and set fuses
avrdude  -c stk500 -B 500 -p atmega328p -P /dev/ttyACM0 -b 115200 -q -q -e  -U efuse:w:0xFD:m
 -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m
##### write the optiboot bootloader to atmega328p and set the lock bits
avrdude  -c stk500 -B 1.50 -p atmega328p -P /dev/ttyACM0 -b 115200 -D -U flash:w:optiboot_atmega328p.hex:i
 -U lock:w:0xef:m
Successfully opened stk500v2 device; in future
please use -c stk500v2, so -x parameters are available

Processing -U flash:w:optiboot_atmega328p.hex:i
Reading 490 bytes for flash from input file optiboot_atmega328p.hex
Writing 490 bytes to flash
Writing | ################################################## | 100% 0.09 s 
Reading | ################################################## | 100% 0.06 s 
490 bytes of flash verified

Processing -U lock:w:0xef:m
Reading 1 byte for lock from input file 0xef
Writing 1 byte (0xEF) to lock, 1 byte written, 1 verified

Avrdude done.  Thank you.
 
\end{Verbatim}
Unfortunately, the operating system knows nothing about the ISP programmer connected to the serial interface.
The programmer's manual or the manufacturer should provide information on setting the ISPTOOL parameter (option -c for \textbf{avrdude}).
If the ISP programmer was developed as part of a project, the project documentation should hopefully provide guidance.
The program \textbf{avrdude} supports many programmers.
If you call \textbf{avrdude} with only the target processor specification \inquotes{-p atmega328p},
127 different programmer options will be listed.
If you exclude the settings that do not use an ISP protocol, 83 options still remain.
Therefore, you should use every opportunity to find a suitable setting for your ISP programmer.
Sometimes the name of the programmer settings displayed by \textbf{avrdude} gives a clue to the suitability of that setting,
as in the following examples:

\begin{itemize}
	\item{arduinoisp         = Arduino ISP Programmer}
	\item{usbasp             = USBasp, http://www.fischl.de/usbasp/}
	\item{usbtiny            = USBtiny simple USB programmer, https://learn.adafruit.com/usbtinyisp }
	\item{dragon\_isp         = Atmel AVR Dragon in ISP mode}
\end{itemize}
